---
section: dataStreams
date: Last Modified
title: "Stream and decode V10 reports for Backed xStock via WebSocket using the Rust SDK"
metadata:
  title: "Backed xStock V10 Reports via WebSocket with Rust SDK | Chainlink Data Streams"
  description: "Step-by-step tutorial on streaming and decoding Backed xStock V10 reports using WebSocket connections with the Rust SDK."
  keywords: ["WebSocket", "Rust SDK", "Backed xStock", "V10 reports", "Data Streams", "Real-time data"]
whatsnext:
  {
    "Learn how to verify your data onchain": "/data-streams/reference/data-streams-api/onchain-verification",
    "Find the list of available Stream IDs": "/data-streams/backed-streams",
  }
---

import { CopyText, PageTabs } from "@components"
import DataStreams from "@features/data-streams/common/DataStreams.astro"

<DataStreams section="dsNotes" />

<PageTabs
  pages={[
    {
      name: "Go SDK - V3 reports for Crypto streams",
      url: "/data-streams/tutorials/ws-go",
      icon: "/images/tutorial-icons/go_logo_black.png",
    },
    {
      name: "Go SDK - V8 reports for RWA streams",
      url: "/data-streams/tutorials/ws-rwa-go",
      icon: "/images/tutorial-icons/go_logo_black.png",
    },
    {
      name: "Go SDK - V9 reports for NAV streams",
      url: "/data-streams/tutorials/ws-nav-go",
      icon: "/images/tutorial-icons/go_logo_black.png",
    },
    {
      name: "Go SDK - V10 reports for Backed assets",
      url: "/data-streams/tutorials/ws-backed-go",
      icon: "/images/tutorial-icons/go_logo_black.png",
    },
    {
      name: "Rust SDK - V3 reports for Crypto streams",
      url: "/data-streams/tutorials/ws-rust",
      icon: "/images/tutorial-icons/rust_logo_blk.svg",
    },
    {
      name: "Rust SDK - V8 reports for RWA streams",
      url: "/data-streams/tutorials/ws-rwa-rust",
      icon: "/images/tutorial-icons/rust_logo_blk.svg",
    },
    {
      name: "Rust SDK - V9 reports for NAV streams",
      url: "/data-streams/tutorials/ws-nav-rust",
      icon: "/images/tutorial-icons/rust_logo_blk.svg",
    },
    {
      name: "Rust SDK - V10 reports for Backed assets",
      url: "/data-streams/tutorials/ws-backed-rust",
      icon: "/images/tutorial-icons/rust_logo_blk.svg",
    },
  ]}
/>

In this tutorial, you'll learn how to use the [Data Streams SDK](/data-streams/reference/data-streams-api/rust-sdk) for Rust to subscribe to real-time [V10 reports](/data-streams/reference/report-schema-v10) for [Backed xStock streams](/data-streams/backed-streams) via a [WebSocket connection](/data-streams/reference/data-streams-api/interface-ws). You'll set up your Rust project, listen for real-time reports from the Data Streams Aggregation Network, decode the report data, and log their attributes to your terminal.

<DataStreams section="asideDisclaimer" />

## Requirements

- **Rust**: Make sure you have Rust installed. You can install Rust by following the instructions on the official [Rust website](https://www.rust-lang.org/tools/install).
- **API Credentials**: Access to Data Streams requires API credentials. If you haven't already, [contact us](https://chainlinkcommunity.typeform.com/datastreams?typeform-source=docs.chain.link#ref_id=docs) to request mainnet or testnet access.

## Tutorial

### Set up your Rust project

1. Create a new directory for your project and navigate to it:

   ```bash
   mkdir my-data-streams-project && cd my-data-streams-project
   ```

1. Initialize a new Rust project:

   ```bash
   cargo init
   ```

1. Add the following dependencies to your `Cargo.toml` file:

   ```toml
   [dependencies]
   chainlink-data-streams-sdk = "1.0.3"
   chainlink-data-streams-report = "1.0.3"
   tokio = { version = "1.4", features = ["full"] }
   hex = "0.4"
   tracing = "0.1"
   tracing-subscriber = { version = "0.3", features = ["time"] }
   ```

### Establish a WebSocket connection and listen for real-time reports

1. Replace the contents of `src/main.rs` with the following code:

   ```rust
   use chainlink_data_streams_report::feed_id::ID;
   use chainlink_data_streams_report::report::{ decode_full_report, v10::ReportDataV10 }; // Import the v10 report schema for Backed asset streams
   use chainlink_data_streams_sdk::config::Config;
   use chainlink_data_streams_sdk::stream::Stream;
   use std::env;
   use std::error::Error;
   use tracing::{ info, warn };
   use tracing_subscriber::fmt::time::UtcTime;

   #[tokio::main]
   async fn main() -> Result<(), Box<dyn Error>> {
      // Initialize logging with UTC timestamps
      tracing_subscriber
         ::fmt()
         .with_timer(UtcTime::rfc_3339())
         .with_max_level(tracing::Level::INFO)
         .init();

      // Get feed IDs from command line arguments
      let args: Vec<String> = env::args().collect();
      if args.len() < 2 {
         eprintln!("Usage: cargo run [StreamID1] [StreamID2] ...");
         std::process::exit(1);
      }

      // Get API credentials from environment variables
      let api_key = env::var("API_KEY").expect("API_KEY must be set");
      let api_secret = env::var("API_SECRET").expect("API_SECRET must be set");

      // Parse feed IDs from command line arguments
      let mut feed_ids = Vec::new();
      for arg in args.iter().skip(1) {
         let feed_id = ID::from_hex_str(arg)?;
         feed_ids.push(feed_id);
      }

      // Initialize the configuration
      let config = Config::new(
         api_key,
         api_secret,
         "https://api.testnet-dataengine.chain.link".to_string(),
         "wss://ws.testnet-dataengine.chain.link".to_string()
      ).build()?;

      // Create and initialize the stream
      let mut stream = Stream::new(&config, feed_ids).await?;
      stream.listen().await?;

      info!("WebSocket connection established. Listening for reports...");

      // Process incoming reports
      loop {
         match stream.read().await {
               Ok(response) => {
                  info!("\nRaw report data: {:?}\n", response.report);

                  // Decode the report
                  let full_report = hex::decode(&response.report.full_report[2..])?;
                  let (_report_context, report_blob) = decode_full_report(&full_report)?;
                  let report_data = ReportDataV10::decode(&report_blob)?;

                  // Print decoded report details
                  info!(
                     "\n--- Report Stream ID: {} ---\n\
                        ------------------------------------------\n\
                        Valid From Timestamp     : {}\n\
                        Observations Timestamp   : {}\n\
                        Expires At               : {}\n\
                        Last Update Timestamp    : {}\n\
                        Price                    : {}\n\
                        Native Fee               : {}\n\
                        Link Fee                 : {}\n\
                        Market Status            : {}\n\
                        Current Multiplier       : {}\n\
                        New Multiplier           : {}\n\
                        Activation DateTime      : {}\n\
                        Tokenized Price          : {}\n\
                        ------------------------------------------",
                     response.report.feed_id.to_hex_string(),
                     report_data.valid_from_timestamp,
                     report_data.observations_timestamp,
                     report_data.expires_at,
                     report_data.last_update_timestamp,
                     report_data.price,
                     report_data.native_fee,
                     report_data.link_fee,
                     report_data.market_status,
                     report_data.current_multiplier,
                     report_data.new_multiplier,
                     report_data.activation_date_time,
                     report_data.tokenized_price
                  );

                  // Print stream stats
                  info!(
                     "\n--- Stream Stats ---\n{:#?}\n\
                        --------------------------------------------------------------------------------------------------------------------------------------------",
                     stream.get_stats()
                  );
               }
               Err(e) => {
                  warn!("Error reading from stream: {:?}", e);
               }
         }
      }

      // Note: In a production environment, you should implement proper cleanup
      // by calling stream.close() when the application is terminated.
      // For example:
      //
      // tokio::select! {
      //     _ = tokio::signal::ctrl_c() => {
      //         info!("Received shutdown signal");
      //         stream.close().await?;
      //     }
      //     result = stream.read() => {
      //         // Process result
      //     }
      // }
   }
   ```

1. Set up your API credentials as environment variables:

   ```bash
   export API_KEY="<YOUR_API_KEY>"
   export API_SECRET="<YOUR_API_SECRET>"
   ```

   Replace `<YOUR_API_KEY>` and `<YOUR_API_SECRET>` with your API credentials.

1. For this example, you'll subscribe to a Backed xStock stream. See the [Backed xStock Streams](/data-streams/backed-streams) page for a complete list of available Backed xStock streams.

   Build and run your application. Replace `[STREAM_ID]` with your stream ID.

   ```bash
   cargo run -- [STREAM_ID]
   ```

   Expect output similar to the following in your terminal:

   ```bash
   2025-07-29T12:09:15.617757Z  INFO rust: WebSocket connection established. Listening for reports...
   2025-07-29T12:09:15.617836Z  INFO chainlink_data_streams_sdk::stream::monitor_connection: Received ping: [49]
   2025-07-29T12:09:15.617877Z  INFO chainlink_data_streams_sdk::stream::monitor_connection: Responding with pong: [49]
   2025-07-29T12:09:15.819279Z  INFO chainlink_data_streams_sdk::stream::monitor_connection: Received new report from Data Streams Endpoint.
   2025-07-29T12:09:15.819631Z  INFO rust:
   Raw report data: Report { feed_id: 0x..., valid_from_timestamp: 1753790956, observations_timestamp: 1753790956, full_report: "0x..." }

   2025-07-29T12:09:15.820629Z  INFO rust:
   --- Report Stream ID: 0x... ---
   ------------------------------------------
   Valid From Timestamp    : 1753790956
   Observations Timestamp  : 1753790956
   Expires At              : 1756382956
   Last Update Timestamp   : 1753790956
   Price                   : 1234500000000000000000
   Native Fee              : 83650421200144
   Link Fee                : 17661691404993071
   Market Status           : 2
   Current Multiplier      : 1000000000000000000
   New Multiplier          : 0
   Activation DateTime     : 0
   Tokenized Price         : 0
   ------------------------------------------
   2025-07-29T12:09:15.82085Z  INFO rust:
   --- Stream Stats ---
   StatsSnapshot {
      accepted: 1,
      deduplicated: 0,
      total_received: 1,
      partial_reconnects: 0,
      full_reconnects: 0,
      configured_connections: 1,
      active_connections: 1,
   }
   --------------------------------------------------------------------------------------------------------------------------------------------
   2025-07-29T12:09:16.504035Z  INFO chainlink_data_streams_sdk::stream::monitor_connection: Received new report from Data Streams Endpoint.
   2025-07-29T12:09:16.504224Z  INFO rust:
   Raw report data: Report { feed_id: 0x..., valid_from_timestamp: 1753790956, observations_timestamp: 1753790956, full_report: "0x..." }

   2025-07-29T12:09:16.504502Z  INFO rust:
   --- Report Stream ID: 0x... ---
   ------------------------------------------
   Valid From Timestamp    : 1753790956
   Observations Timestamp  : 1753790956
   Expires At              : 1756382956
   Last Update Timestamp   : 1753790956
   Price                   : 1234500000000000000000
   Native Fee              : 83650421200144
   Link Fee                : 17661691404993071
   Market Status           : 2
   Current Multiplier      : 1000000000000000000
   New Multiplier          : 0
   Activation DateTime     : 0
   Tokenized Price         : 0
   ------------------------------------------
   2024-08-12T10:30:16.504541Z  INFO rust:
   --- Stream Stats ---
   StatsSnapshot {
      accepted: 2,
      deduplicated: 0,
      total_received: 2,
      partial_reconnects: 0,
      full_reconnects: 0,
      configured_connections: 1,
      active_connections: 1,
   }

   [...]
   ```

The example above demonstrates streaming data from a single Backed xStock stream. For production environments, especially when subscribing to multiple streams, it's recommended to enable [High Availability (HA) mode](https://github.com/smartcontractkit/data-streams-sdk/blob/main/rust/docs/examples/wss_multiple.md). This can be achieved by:

1. Adding multiple WebSocket endpoints in the configuration:

   ```rust
   "wss://ws.testnet-dataengine.chain.link,wss://ws.testnet-dataengine.chain.link"
   ```

1. Enabling HA mode in the configuration:
   ```rust
   use chainlink_data_streams_sdk::config::WebSocketHighAvailability;
   // ...
   .with_ws_ha(WebSocketHighAvailability::Enabled)
   ```

When HA mode is enabled and multiple WebSocket origins are provided, the Stream will maintain concurrent connections to different instances. This ensures high availability, fault tolerance, and minimizes the risk of report gaps.

You can subscribe to multiple streams by providing additional stream IDs as command-line arguments. Replace `[STREAM_ID_1]` and `[STREAM_ID_2]` with your stream IDs.

```bash
cargo run -- [STREAM_ID_1] [STREAM_ID_2]
```

This will subscribe to both streams.

#### Decoded report details

The decoded report details include:

| Field                   | Example Value            | Description                                                                                                          |
| ----------------------- | ------------------------ | -------------------------------------------------------------------------------------------------------------------- |
| `feedId`                | `0x...`                  | Unique identifier for the Data Streams feed                                                                          |
| `validFromTimestamp`    | `1753790956`             | Earliest timestamp when the price is valid                                                                           |
| `observationsTimestamp` | `1753790956`             | Latest timestamp when the price is valid                                                                             |
| `nativeFee`             | `83650421200144`         | Cost to verify report onchain (native token)                                                                         |
| `linkFee`               | `17661691404993071`      | Cost to verify report onchain (LINK)                                                                                 |
| `expiresAt`             | `1756382956`             | Expiration date of the report                                                                                        |
| `lastUpdateTimestamp`   | `1753790956`             | Timestamp of the last valid price update                                                                             |
| `price`                 | `1234500000000000000000` | Last traded price from the real-world equity market                                                                  |
| `marketStatus`          | `2`                      | Status of the real-world equity market. <br/> Possible values: `0` (Unknown), `1` (Closed), `2` (Open), `3` (Halted) |
| `currentMultiplier`     | `1000000000000000000`    | Currently applied multiplier accounting for past corporate actions                                                   |
| `newMultiplier`         | `0`                      | Multiplier to be applied at the activationDateTime <br/> (set to `0` if none is scheduled)                           |
| `activationDateTime`    | `0`                      | When the next corporate action takes effect <br/> (set to `0` if none is scheduled)                                  |
| `tokenizedPrice`        | `0`                      | 24/7 tokenized equity price as traded on supported exchanges <br/> (In development; currently returns `0`).          |

#### Payload for onchain verification

In this tutorial, you log and decode the `full_report` payload to extract the report data. In a
production environment, you should verify the data to ensure its integrity and authenticity. Refer to the
[Verify report data onchain](/data-streams/tutorials/evm-onchain-report-verification) tutorial.

## Explanation

### Establishing a WebSocket connection and listening for reports

The WebSocket connection is established in two steps:

1. [`Stream::new`](https://github.com/smartcontractkit/data-streams-sdk/blob/main/rust/crates/sdk/src/stream.rs#L131) initializes a new stream instance with your configuration and feed IDs. This function prepares the connection parameters but doesn't establish the connection yet.

1. [`stream.listen()`](https://github.com/smartcontractkit/data-streams-sdk/blob/main/rust/crates/sdk/src/stream.rs#L162) establishes the actual WebSocket connection and starts the background tasks that maintain the connection. These tasks handle:
   - Automatic reconnection if the connection is lost
   - Ping/pong messages to keep the connection alive
   - Message queueing and delivery

### Decoding a report

As data reports arrive via the WebSocket connection, they are processed in real-time through several steps:

1. Reading streams: The [`read`](https://github.com/smartcontractkit/data-streams-sdk/blob/main/rust/crates/sdk/src/stream.rs#L218) method on the Stream object is called within a loop. This asynchronous method:

   - Awaits the next report from the WebSocket connection
   - Handles backpressure automatically
   - Returns a `WebSocketReport` containing the report data

1. Decoding reports: Each report is decoded in two stages:
   - [`decode_full_report`](https://github.com/smartcontractkit/data-streams-sdk/blob/main/rust/crates/report/src/report.rs#L83) parses the raw hexadecimal data, separating the report context (containing metadata) from the report blob
   - [`ReportDataV10::decode`](https://github.com/smartcontractkit/data-streams-sdk/blob/main/rust/crates/report/src/report/v10.rs#L74) transforms the report blob into a structured format containing:
     - `price`: Last traded price from the real-world equity market
     - `market_status`: Status of the real-world equity market (0=Unknown, 1=Closed, 2=Open, 3=Halted)
     - `current_multiplier`: Currently applied multiplier accounting for past corporate actions
     - `new_multiplier`: Multiplier to be applied at the `activation_date_time` (set to 0 if none is scheduled)
     - `activation_date_time`: When the next corporate action takes effect (set to 0 if none is scheduled)
     - `tokenized_price`: 24/7 tokenized equity price as traded on supported exchanges (currently always returns 0)

### Handling the decoded data

The example demonstrates several best practices for handling the decoded data:

1. Logging:

   - Uses the [`tracing`](https://github.com/tokio-rs/tracing) crate for structured logging
   - Configures UTC timestamps for consistent time representation
   - Includes both raw report data and decoded fields for debugging

1. Error handling:

   - Uses Rust's `Result` type for robust error handling
   - Implements the `?` operator for clean error propagation
   - Logs errors with appropriate context using `warn!` macro

1. Stream monitoring:
   - Tracks stream statistics through [`get_stats()`](https://github.com/smartcontractkit/data-streams-sdk/blob/main/rust/crates/sdk/src/stream.rs#L253)
   - Monitors connection status and reconnection attempts
   - Reports message acceptance and deduplication counts

The decoded data can be used for further processing, analysis, or display in your application. For production environments, it's recommended to verify the data onchain using the provided `full_report` payload.
