---
section: dataStreams
date: "Last Modified"
title: "Calculated Streams"
metadata:
  title: "Chainlink Calculated Streams | Derived Data Stream Values"
  description: "Learn about Calculated Streams in Chainlink Data Streams - streams whose values are derived from multiple underlying inputs using predefined expressions."
  keywords:
    [
      "Calculated Streams",
      "Data Streams",
      "Derived Values",
      "Index Pricing",
      "Collateral Values",
      "Tokenized Assets",
      "Stream Calculations",
    ]
whatsnext:
  {
    "Find the list of available Crypto streams": "/data-streams/crypto-streams",
    "Find the list of available RWA streams": "/data-streams/rwa-streams",
    "Learn about Data Streams architecture": "/data-streams/architecture",
    "Data Streams Best Practices": "/data-streams/concepts/best-practices",
  }
---

import { Aside, ClickToZoom } from "@components"

Calculated streams are Chainlink data streams whose values are derived by applying arithmetic expressions to multiple underlying inputs.

All Data Streams use a [Decentralized Oracle Network (DON)](/data-streams/architecture) where nodes reach consensus and publish signed reports. Traditional Data Streams aggregate market data from multiple independent providers, ensuring no single data source can compromise the stream's integrity.

Instead of aggregating only raw market data, calculated streams compute derived values using predefined formulas applied to various inputs, including existing data streams, onchain state, and offchain APIs. Some inputs are decentralized aggregates (for example, crypto price streams from multiple independent providers), while others may come from a single protocol or API (for example, a specific vault contract or yield provider). Because a calculated stream depends on all of these inputs, you should evaluate their dependencies and failure modes carefully before using it in a value-securing application.

<Aside type="caution" title="Important Considerations">
  Calculated streams behave differently from standard streams in important ways. Before integrating a calculated stream,
  review the <a href="#key-differences-from-standard-streams">key differences</a> and{" "}
  <a href="#risks-and-mitigation">risks and mitigation</a> sections to understand how these differences may affect your
  application.
</Aside>

## Why use calculated streams?

- **Simpler integrations**: Consume one stream instead of implementing calculation logic in your contracts or backend
- **Canonical formulas**: All integrators use the same formula and inputs, ensuring consistency across protocols
- **Managed infrastructure**: Chainlink handles RPC calls, API integrations, and the calculation pipeline

## How to identify calculated streams

Calculated streams are marked with a <span style="display: inline-block; font-size: 0.75rem; padding: 2px 6px; margin-left: 4px; border-radius: 4px; background: var(--blue-100); color: var(--blue-700); font-weight: 500; vertical-align: middle;">Calculated</span> badge in the Data Streams feed list.

## How calculated streams work

Calculated streams leverage existing Data Streams infrastructure. Data providers feed market data into the DON, which produces base streams. The DON then uses these base streams—along with onchain state and offchain APIs—as inputs to calculate derived values.

<ClickToZoom
  src="/images/data-streams/calculated-streams-diagram.png"
  alt="Calculated Streams architecture diagram showing data providers feeding into LLO DON nodes, which perform index price calculations and output to channels containing multiple streams."
/>

### Architecture flow

1. **Data collection**: The DON retrieves inputs specific to each calculated stream, which may include:
   - Existing Data Streams (market prices from multiple independent data providers)
   - Onchain state via RPC calls (vault balances, token supplies, contract data)
   - Offchain data via APIs (yield rates, interest components, external reference data)
2. **Calculation**: The DON applies the predefined formula to combine the inputs
3. **Consensus and signing**: Nodes reach consensus on the calculated value and sign the report
4. **Publication**: Calculated streams are published through the Data Streams Aggregation Network

### Input sources

The inputs for a calculated stream depend on what it's computing. A stream might use:

#### Existing Data Streams

Market prices already aggregated from multiple independent sources (3+ providers). Example: using individual crypto asset prices as inputs for an index calculation.

#### Onchain state

Protocol-specific data read via RPC, such as vault balances, token supplies, or smart contract state. May come from a single protocol's contracts.

#### Offchain APIs

External data from specific trusted providers, such as yield rates or reference values. May come from a single API endpoint.

### Calculation and output

The DON executes the predefined formula (weighted averages, ratios, sums, etc.) using the latest available inputs. The calculated value is packaged into a signed report with standard metadata (timestamps, fees) and published through the Data Streams Aggregation Network. You consume these reports using the same REST APIs, WebSocket connections, and onchain verification as traditional streams.

## Example: Tokenized yield product

A calculated stream for a tokenized yield-bearing vault might combine:

- **Vault balance (onchain)**: Total assets in the vault contract
- **Token supply (onchain)**: Circulating supply of vault shares
- **Accrued yield (offchain)**: Interest from an external API

**Formula:** `(vault balance + accrued yield) / token supply`

**Result**: a price per share that reflects the vault's total value including pending yield.

Without this stream, protocols accepting the vault token as collateral would need to query the vault contract, fetch accrued interest from the yield provider's API, perform the calculation themselves, and keep this logic synchronized across all integrators. A calculated stream helps ensure integrators apply the same pricing logic and update together when the underlying formula or yield source changes.

## Key differences from standard streams

While calculated streams use the same infrastructure and delivery mechanisms as standard streams, they have distinct behaviors you should understand before integrating.

### Report availability

Standard streams aggregate data from multiple independent providers, so they remain available as long as enough providers are reporting. Calculated streams depend on **all** of their inputs being available. If any required input becomes unavailable or returns errors, the calculated **stream stops producing reports until all inputs recover**. This prevents potentially incorrect values from being published.

### Input reliability

Standard streams source data exclusively from decentralized aggregates of multiple independent data providers. Calculated streams may include a mix of:

- **Decentralized aggregates**: Existing Data Streams with multiple independent sources (similar reliability to standard streams)
- **Single-source inputs**: Specific protocol contracts or APIs where availability depends on a single system

Single-source inputs carry higher risk. If that source experiences downtime, report production halts entirely until it recovers. Review the input sources for any calculated stream you plan to use.

### Timing characteristics

Standard streams reflect a single aggregated market price at a point in time. Calculated streams combine multiple inputs that may update at different frequencies and reflect slightly different timestamps. The calculated value is an approximation based on the latest available data from each input, not a single-block atomic snapshot.

During rapid changes (large deposits, withdrawals, or sharp market moves), you may observe temporary differences between the calculated stream value and values from other sources like block explorers or protocol dashboards. These differences typically resolve as all inputs update to reflect the new state.

---

## Risks and mitigation

Calculated streams inherit risks from their underlying inputs and introduce additional considerations. Use these strategies to mitigate potential issues.

### Handling report gaps

Because calculated streams stop producing reports when any input fails, your application must handle gaps in report availability.

#### Mitigation

- Design your protocol to handle report gaps gracefully (pause operations, use last-known values with appropriate staleness checks, or implement fallbacks based on your risk tolerance)
- Implement staleness checks to detect when reports stop arriving and trigger appropriate protocol responses
- Set alerts for report gaps to detect input source issues early

### Single-source input reliability

Single-source inputs (specific APIs or contracts) may have lower availability than decentralized aggregates.

#### Mitigation

- Understand your input sources and assess the reliability of each, particularly single-source APIs or contracts
- For critical applications, consider independently monitoring the availability of single-source inputs
- Define acceptable downtime thresholds and corresponding protocol responses

### Timing discrepancies

Temporary differences between the calculated stream and other data sources are expected during rapid changes.

#### Mitigation

- Implement max deviation checks against expected ranges
- Use time-weighted averages or circuit breakers for extreme moves
- Monitor trends over time rather than reacting to individual updates
- Compare calculated values against market references when available (e.g., spot prices for index tokens)

<Aside type="note" title="Developer Responsibilities">
  When using calculated streams, you inherit all responsibilities associated with the underlying inputs plus additional
  responsibilities for monitoring calculation health and managing time-sensitivity requirements. Review the{" "}
  <a href="/data-streams/developer-responsibilities">Developer Responsibilities</a> page for comprehensive guidance on
  risk assessment and mitigation techniques.
</Aside>

---

## Best practices

### Protocol design

- Set deviation limits to cap price changes per update or time window
- Define fallback behavior if the stream stops updating or jumps beyond thresholds
- Test your protocol's behavior during report gaps before deploying to production

### Monitoring

- Set alerts for report gaps to detect when no new reports arrive within your expected update frequency
- Track the calculated stream value over time to establish normal behavior patterns
- Monitor key inputs independently when feasible (vault balances, token supplies, API availability) to identify which input may be causing issues
- Alert on movements outside your expected range
