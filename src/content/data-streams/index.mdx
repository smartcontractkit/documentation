---
section: dataStreams
title: "Chainlink Data Streams"
isIndex: true
metadata:
  title: "Chainlink Data Streams | Low-Latency, High-Frequency Market Data"
  description: "Access high-frequency, low-latency market data offchain that can be cryptographically verified onchain for decentralized applications and DeFi protocols."
  keywords: ["Chainlink", "Data Streams", "Oracle", "DeFi", "Market Data", "Low Latency", "High Frequency"]
whatsnext:
  {
    "Learn how to fetch and decode Data Streams reports with the API": "/data-streams/tutorials/go-sdk-fetch",
    "Find the list of available Stream IDs": "/data-streams/crypto-streams",
    "Find the schema of data to expect from Data Streams reports: Crypto": "/data-streams/reference/report-schema-v3",
    "Find the schema of data to expect from Data Streams reports: RWA": "/data-streams/reference/report-schema-v8",
  }
---

import { Aside, ClickToZoom } from "@components"
import DataStreams from "@features/data-streams/common/DataStreams.astro"

<DataStreams section="dsNotes" />

Chainlink Data Streams delivers low-latency market data offchain, which you can verify onchain. This approach provides decentralized applications (dApps) with on-demand access to high-frequency market data backed by decentralized, fault-tolerant, and transparent infrastructure.

Traditional push-based oracles update onchain data at set intervals or when certain price thresholds are met. In contrast, Chainlink Data Streams uses a pull-based design that preserves trust-minimization with onchain verification.

Data Streams are offered in [several report formats](/data-streams/reference/report-schema-overview), each designed for distinct asset classes.

See data sourcing details in the [Data Sources](/data-streams/data-sources) page.

## Sub-Second Data and Commit-and-Reveal

Chainlink Data Streams supports sub-second data resolution for latency-sensitive use cases by retrieving data only when needed. You can combine the data with any transaction in near real time. A "commit-and-reveal" approach mitigates frontrunning by making trade data and stream data visible atomically onchain.

## Comparison to push-based oracles

Chainlink's push-based oracles regularly publish price data onchain. By contrast, Chainlink Data Streams relies on a pull-based design, letting you retrieve a report and verify it onchain whenever you need it. Verification confirms that the decentralized oracle network (DON) agreed on and signed the data. Some applications only need onchain data at fixed intervals, which suits push-based oracles. However, others require higher-frequency updates and lower latency. Pull-based oracles meet these needs and still provide cryptographic guarantees about data accuracy.

<ClickToZoom
  src="/images/data-streams/push-based-vs-pull-based-oracles.webp"
  alt="Chainlink Data Streams - Push-Based vs Pull-Based Oracles"
  caption="Push-based and pull-based oracles comparison"
/>

Pull-based oracles also operate more efficiently by retrieving data only when necessary. For example, a decentralized exchange might fetch a Data Streams report and verify it onchain only when a user executes a trade, rather than continuously pushing updates that might not be immediately used.

## Comprehensive market insights

Chainlink Data Streams offers price points such as mid prices and [Liquidity-Weighted Bid and Ask](/data-streams/concepts/liquidity-weighted-prices) (LWBA) for Crypto Streams. LWBA prices reflect current order book conditions, providing deeper insight into market liquidity and depth. With additional parameters, such as volatility and liquidity metrics, Data Streams helps protocols enhance trading accuracy, improve onchain risk management, and dynamically adjust margins or settlement conditions in response to real-time market shifts.

## High availability and resilient infrastructure

Data Streams API services use an [active-active multi-site deployment](/data-streams/architecture#active-active-multi-site-deployment) model across multiple distributed and isolated origins. This architecture ensures continuous operations even if one origin fails, delivering robust fault tolerance and high availability.

For real-time streaming applications, the SDKs support **High Availability (HA) mode** that establishes multiple simultaneous connections for zero-downtime operation. When enabled, HA mode provides:

- **Automatic failover** between connections
- **Report deduplication** across connections
- **Automatic origin discovery** to find available endpoints
- **Per-connection monitoring** and statistics

**Learn more:** [Go SDK](/data-streams/reference/data-streams-api/go-sdk#high-availability-ha-mode) | [Rust SDK](/data-streams/reference/data-streams-api/rust-sdk#high-availability-mode) | [TypeScript SDK](/data-streams/reference/data-streams-api/ts-sdk#high-availability-mode)

## Example use cases

Access to low-latency, high-frequency data enables a variety of onchain applications:

- **Perpetual Futures:** Sub-second data and frontrunning mitigation allow onchain perpetual futures protocols to compete with centralized exchanges on performance while retaining transparency and decentralization.
- **Options:** Pull-based oracles provide timely settlement of options contracts with the added benefit of market liquidity data to support dynamic onchain risk management.
- **Prediction Markets:** High-frequency updates let participants act on real-time data, ensuring quick reactions to events and accurate settlement.

## Key capabilities

- **Sub-second Latency:** Pull data on-demand with minimal delay
- **Cryptographic Verification:** Verify data authenticity onchain when needed
- **Multiple Access Methods:** REST API, WebSocket, or SDK integration
- **Comprehensive Market Data:** Mid prices, LWBA prices, volatility, and liquidity metrics
- **High Availability:** Multi-site deployment ensures 99.9%+ uptime

## How to use Data Streams

You can access Chainlink Data Streams through SDKs and APIs, allowing you to build custom solutions with low-latency, high-frequency data. Fetch reports or subscribe to report updates from the Data Streams Aggregation Network and verify their authenticity onchain.

<ClickToZoom
  src="/images/data-streams/data-streams-on-demand-offchain-workflows.webp"
  alt="Chainlink Data Streams - On-Demand Offchain Workflows"
  caption="Chainlink Data Streams - On-Demand Offchain Workflows"
/>

### Integration options

Access data directly through REST APIs or WebSocket connections using our SDKs:

- **[Go SDK](/data-streams/reference/data-streams-api/go-sdk)** - Full-featured SDK with comprehensive examples
- **[Rust SDK](/data-streams/reference/data-streams-api/rust-sdk)** - High-performance SDK for Rust applications
- **[TypeScript SDK](/data-streams/reference/data-streams-api/ts-sdk)** - Type-safe SDK for TypeScript applications
- **[REST API](/data-streams/reference/data-streams-api/interface-api)** or **[WebSocket](/data-streams/reference/data-streams-api/interface-ws)** - Direct access to Data Streams endpoints

### Getting started

1. Understand the Architecture: Review the [system components and data flow](/data-streams/architecture) to understand how Data Streams works.

1. Explore Available Data: Browse [available reports and associated schemas](/data-streams/reference/report-schema-overview) to see what data is available.

1. Try the API: Follow our [hands-on tutorial](/data-streams/tutorials/go-sdk-fetch) to fetch and decode your first report.

1. Implement Verification: Add [onchain verification](/data-streams/reference/data-streams-api/onchain-verification) to ensure data authenticity in your smart contracts.

## Alternative implementations

### Streams Trade

For applications that require automated data retrieval and execution, Streams Trade combines Chainlink Data Streams with [Chainlink Automation](/chainlink-automation) to deliver automated trade execution with frontrunning mitigation. This approach suits dApps that require automated, trust-minimized trade execution and high-frequency market data.

[Learn more about Streams Trade](/data-streams/streams-trade).

### Push Engine

<Aside type="caution" title="Disclaimer">
  This reference implementation is provided to help you understand how to interact with Chainlink's systems and services
  so that you can integrate them into your own. This reference implementation is provided on an “AS IS” and “AS
  AVAILABLE” basis without any representations, warranties, covenants, or conditions of any kind. Use at your own risk.
  Users remain fully responsible for reviewing, auditing, and deploying any code or contracts. Do not use the code in
  this reference implementation in a production environment without completing your own audits and application of best
  practices. Neither Chainlink Labs, the Chainlink Foundation, nor Chainlink node operators are responsible for
  unintended outputs that are generated due to errors in code. Please review the Chainlink Terms of Service which
  provides important information and disclosures. By using this reference implementation, you expressly acknowledge and
  agree to accept these terms.
</Aside>

While Data Streams provides low-latency data offchain, bringing verified reports onchain requires developers to build and maintain a custom service to monitor the feed and push updates.

[Push Engine](https://github.com/hackbg/push-engine), a reference implementation made available for third-party integrators, provides a foundational framework for the DevOps teams and Infrastructure Managers tasked with building these systems. Push Engine is a configurable service that handles the core logic of monitoring off-chain Data Streams and pushing values to your smart contracts based on predefined conditions, such as time intervals or price deviations. It also includes a web interface to manage your feeds and monitor their status.

Based on predefined conditions like time intervals or price deviations, Push Engine bundles and sends a report for onchain verification and consumption. This approach suits dApps that need fresh data pushed onchain based on custom logic, without the overhead of building and maintaining the necessary infrastructure.

[See our quickstart guide for Push Engine](/quickstarts/push-engine).
