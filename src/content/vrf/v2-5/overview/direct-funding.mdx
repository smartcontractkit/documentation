---
section: vrf
date: Last Modified
title: "Direct Funding Method"
whatsnext:
  {
    "Get a Random Number": "/vrf/v2-5/direct-funding/get-a-random-number",
    "Supported Networks": "/vrf/v2-5/supported-networks",
  }
metadata:
  title: "Generate Random Numbers for Smart Contracts using Chainlink VRF v2.5 - Direct funding method"
  description: "Learn how to securely generate random numbers for your smart contract with Chainlink VRF v2.5. This guide uses the Direct funding method."
---

import VrfCommon from "@features/vrf/v2/common/VrfCommon.astro"
import { Aside, ClickToZoom } from "@components"

This guide explains how to generate random numbers using the _direct funding_ method. This method doesn't require a subscription and is optimal for one-off requests for randomness. This method also works best for applications where your end-users must pay the fees for VRF because the cost of the request is determined at request time.

<Aside type="note" title="Migrate to V2.5">
  Follow the [migration guide](/vrf/v2-5/migration-from-v2) to learn how VRF has changed in V2.5 and to get example
  code.
</Aside>

Unlike the [subscription method](/vrf/v2-5/overview/subscription), the direct funding method does not require you to create subscriptions and pre-fund them. Instead, you must directly fund consuming contracts with native tokens or LINK before they request randomness. Because the consuming contract directly pays for the request, the cost is calculated during the request and not during the callback when the randomness is fulfilled. Learn [how to estimate costs](/vrf/v2-5/billing).

## Request and receive data

Requests to Chainlink VRF v2.5 follow the request and receive data cycle similarly to VRF V2. This end-to-end diagram shows each step in the lifecycle of a VRF direct funding request:

<ClickToZoom src="/images/vrf/v2-5/direct-funding-architecture-diagram.png" />

The Chainlink VRF v2.5 solution uses both offchain and onchain components:

- [VRF v2.5 Wrapper (onchain component)](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/dev/VRFV2PlusWrapper.sol): A wrapper for the VRF Coordinator that provides an interface for consuming contracts.
- [VRF v2.5 Coordinator (onchain component)](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/dev/VRFCoordinatorV2_5.sol): A contract designed to interact with the VRF service. It emits an event when a request for randomness is made, and then verifies the random number and proof of how it was generated by the VRF service.
- VRF service (offchain component): Listens for requests by subscribing to the VRF Coordinator event logs and calculates a random number based on the block hash and nonce. The VRF service then sends a transaction to the `VRFCoordinator` including the random number and a proof of how it was generated.

### Account types used in VRF

Two types of accounts exist in the Ethereum ecosystem, and both are used in VRF:

- EOA (Externally Owned Account): An externally owned account that has a private key and can control a smart contract. Transactions can be initiated only by EOAs.
- Smart contract: A smart contract that does not have a private key and executes what it has been designed for as a decentralized application.

While only EOAs can initiate transactions, do not attempt to use EOAs to send VRF requests directly. Instead, your EOA should interact with your consuming contract: the smart contract that is consuming the random values you request from VRF. Your EOA initiates the transaction, and then your consuming contract interacts with the VRF Wrapper contract, which sends the VRF request.

### Set up your contract and request

Set up your consuming contract:

1. Your contract must inherit [VRFV2PlusWrapperConsumerBase](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/dev/VRFV2PlusWrapperConsumerBase.sol).

1. Your contract must implement the `fulfillRandomWords` function, which is the _callback VRF function_. Here, you add logic to handle the random values after they are returned to your contract.

1. Submit your VRF request by calling the `requestRandomness` function in the [VRFV2PlusWrapperConsumerBase](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/dev/VRFV2PlusWrapperConsumerBase.sol) contract. Include the following parameters in your request:

   - `requestConfirmations`: The number of block confirmations the VRF service will wait to respond. The minimum and maximum confirmations for your network can be found [here](/vrf/v2-5/supported-networks#configurations).
   - `callbackGasLimit`: The maximum amount of gas to pay for completing the callback VRF function.
   - `numWords`: The number of random numbers to request. You can find the maximum number of random values per request for your network in the [Supported networks](/vrf/v2-5/supported-networks#configurations) page.
   - `extraArgs`: A parameter for additional arguments related to new VRF features, such as enabling payment in native tokens.

### How VRF processes your request

After you submit your request, it is processed using the [Request & Receive Data](#request-and-receive-data) cycle:

1. The consuming contract calls the [VRFV2PlusWrapper](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/dev/VRFV2PlusWrapper.sol) `calculateRequestPrice` function to estimate the total transaction cost to fulfill randomness. Learn [how to estimate transaction costs](/vrf/v2-5/billing).

1. The consuming contract calls the [LinkToken](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/shared/token/ERC677/LinkToken.sol) `transferAndCall` function to pay the wrapper with the calculated request price. This method sends LINK tokens and executes the [VRFV2PlusWrapper](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/dev/VRFV2PlusWrapper.sol) `onTokenTransfer` logic.

1. The VRFV2PlusWrapper's `onTokenTransfer` logic triggers the [VRF 2.5 Coordinator](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/dev/VRFCoordinatorV2_5.sol) `requestRandomWords` function to request randomness.

1. The VRF coordinator emits an event.

1. The VRF service picks up the event and waits for the specified number of block confirmations to respond back to the VRF coordinator with the random values and a proof (`requestConfirmations`).

1. The VRF coordinator verifies the proof onchain, then it calls back the wrapper contract's `fulfillRandomWords` function.

1. Finally, the VRF Wrapper calls back your consuming contract.

## Limits

You can see the configuration for each network on the [Supported networks](/vrf/v2-5/supported-networks) page. You can also view the full configuration for each VRF v2.5 Wrapper contract directly in Etherscan. As an example, view the [Ethereum Mainnet VRF v2.5 Wrapper contract](https://etherscan.io/address/0x02aae1A04f9828517b3007f83f6181900CaD910c#readContract) configuration by calling `getConfig` function.

- Each wrapper has a `maxNumWords` parameter that limits the maximum number of random values you can receive in each request.
- The maximum allowed `callbackGasLimit` value for your requests is defined in the [Coordinator contract supported networks](/vrf/v2-5/supported-networks) page. Because the VRF v2.5 Wrapper adds an overhead, your `callbackGasLimit` must not exceed `maxGasLimit - wrapperGasOverhead`. Learn more about [estimating costs](/vrf/v2-5/billing).
