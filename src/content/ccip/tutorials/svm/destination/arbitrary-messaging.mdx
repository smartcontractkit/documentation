---
section: ccip
date: Last Modified
title: "Arbitrary Messaging: EVM to SVM"
isIndex: false
metadata:
  description: "Learn how to send arbitrary data messages from Ethereum to Solana programs using Chainlink's Cross-Chain Interoperability Protocol (CCIP). This step-by-step tutorial guides you through configuring and executing data-only cross-chain messages."
  excerpt: "cross-chain arbitrary messaging evm to solana ccip tutorial ethereum sepolia solana program"
---

import { Aside, ClickToZoom, CodeBlock } from "@components"
import { Tabs } from "@components/Tabs"
import CcipCommon from "@features/ccip/CcipCommon.astro"

This tutorial demonstrates how to send arbitrary data from an Ethereum Virtual Machine (EVM) chain to a program on a SVM chain using Chainlink's Cross-Chain Interoperability Protocol (CCIP). You will learn how to configure CCIP messages that trigger a program execution on the destination chain.

<Aside type="note" title="Prerequisites">
  Make sure you understand how to [build CCIP messages from EVM to SVM](/ccip/tutorials/svm/destination) before
  beginning this tutorial.
</Aside>

## Introduction

This tutorial shows you how to send data-only messages from Ethereum Sepolia to a receiver program on Solana devnet.

## What You will Build

In this tutorial, you will:

- Configure a CCIP message for arbitrary data messaging
- Send data from Ethereum Sepolia to a Solana program
- Pay for CCIP transaction fees using LINK tokens
- Verify the data was received and processed by the program

## Prerequisites

Before starting, ensure you have:

1. **Development Environment**:

   - Node.js v20 or higher. You can use the [nvm package](https://www.npmjs.com/package/nvm) to install and switch between Node.js versions.
   - Git for cloning the repository.
   - [Yarn](https://yarnpkg.com/) for installing dependencies.

1. **Tokens for Testing**:

   - ETH on Sepolia (for transaction gas).
   - LINK on Sepolia (for CCIP fees).

1. **Wallets**:

   - An Ethereum wallet with a private key. If you use MetaMask, you can follow this [guide](https://support.metamask.io/managing-my-wallet/secret-recovery-phrase-and-private-keys/how-to-export-an-accounts-private-key/) to export your private key.

1. **RPC URLs**:
   - An Ethereum RPC URL. You can sign up for a personal endpoint from [Alchemy](https://www.alchemy.com/), [Infura](https://www.infura.io/), or another node provider service.

<Aside type="tip" title="Obtaining Test Tokens">
  Get ETH and LINK from the [Chainlink Faucet](https://faucets.chain.link/). Unlike the token transfer tutorial, you
  don't need CCIP-BnM tokens for arbitrary messaging.
</Aside>

## Setup Instructions

### 1. Clone the Repository

```bash
git clone https://github.com/smartcontractkit/solana-starter-kit-private.git
cd solana-starter-kit-private
```

### 2. Install Dependencies

```bash
yarn install
```

### 3. Configure Environment Variables

Create a `.env` file in the project root based on the provided example:

```
EVM_PRIVATE_KEY=your_private_key_here
EVM_RPC_URL=your_rpc_url_here
```

## Understanding Arbitrary Messaging to SVM

This tutorial focuses on arbitrary messaging from EVM chains to SVM programs. For detailed information about CCIP message structure and parameters, refer to the [guide on building CCIP messages from EVM to SVM](/ccip/tutorials/svm/destination).

Key points specific to arbitrary messaging:

- **Program Execution**: Messages trigger program execution on the destination chain
- **Mandatory Settings**:
  - `computeUnits` must be sufficient for the execution of `ccip_receive` instruction of the receiver program
  - `receiver` field should be set to the Solana program ID
  - `tokenReceiver` is typically set to the default PublicKey (`11111111111111111111111111111111`)
  - Required accounts must be specified in the `accounts` array
  - `accountIsWritableBitmap` must correctly identify which accounts should be writable
  - `allowOutOfOrderExecution` must be `true`

For more details on the CCIP message structure, `extraArgs`, and how the SVM account model works, refer to the [guide on building CCIP messages from EVM to SVM](/ccip/tutorials/svm/destination).

### Key Differences from Token Transfers

<Tabs client:visible>
  <Fragment slot="tab.1">Purpose</Fragment>
  <Fragment slot="tab.2">Configuration</Fragment>
  <Fragment slot="tab.3">Destination</Fragment>
  <Fragment slot="tab.4">Verification</Fragment>
  <Fragment slot="panel.1">
    **Token Transfers**:
    - Simply move assets between chains
    - No program execution on destination

    **Arbitrary Messaging**:
    - Sends data for processing by a program
    - Triggers program execution on destination
    - Can update program state or perform complex logic

  </Fragment>
  <Fragment slot="panel.2">
    **Token Transfers**:
    - `computeUnits` must be 0
    - `receiver` is default PublicKey
    - `tokenReceiver` is the recipient wallet
    - No accounts required

    **Arbitrary Messaging**:
    - `computeUnits` must be sufficient to execute the `ccip_receive` instruction of the receiver program
    - `receiver` is a Solana program ID
    - `tokenReceiver` is typically default PublicKey
    - Requires specific accounts and proper bitmap

  </Fragment>
  <Fragment slot="panel.3">
    **Token Transfers**:
    - Tokens arrive in a wallet or PDA of a receiver program
    - No program execution happens

    **Arbitrary Messaging**:
    - Data arrives at a Solana program
    - Program executes to process the data
    - Program can update its state accounts

  </Fragment>
  <Fragment slot="panel.4">
    **Token Transfers**:
    - Check token balance in wallet
    - Use Solana Explorer to verify balances

    **Arbitrary Messaging**:
    - Verify program state changes
    - Use program-specific methods to retrieve data
    - Check transaction logs for program execution

  </Fragment>
</Tabs>

### The CCIP Basic Receiver Program

This tutorial uses the [Basic Receiver program](https://github.com/smartcontractkit/solana-starter-kit-private/tree/main/programs/ccip-basic-receiver) deployed on [Solana Devnet](https://explorer.solana.com/address/BqmcnLFSbKwyMEgi7VhVeJCis1wW26VySztF34CJrKFq?cluster=devnet) as the destination program. This sample program:

- Implements the CCIP receiver interface
- Receives and stores cross-chain messages
- Allows retrieval of the last message data

<Aside type="note" title="Scope Clarification">
  Learning how to write, deploy, and initialize a Solana program is outside the scope of this tutorial. This guide
  focuses on sending messages to an existing program. The principles you will learn can be applied to any Solana program
  that implements the CCIP receiver interface.
</Aside>

### Understanding Program Derived Addresses (PDAs)

To interact with Solana programs, you need to understand Program Derived Addresses (PDAs):

    - PDAs are deterministic addresses derived from seeds and a program ID
    - They provide onchain storage for Solana programs
    - Each PDA serves a specific purpose
    - When sending messages to a program, you must specify all accounts (including PDAs) that the program requires

For the CCIP Basic Receiver program, we need two main PDAs:

1.  **State PDA**:

    - Contains essential program settings like the router address and owner
    - Derived using the seed "state"
    - Controlled by the program owner/authority
    - The State PDA is critical for validating incoming messages in the `ccip_receive` instruction. It stores the trusted router program ID, which is used to authenticate the caller
    - When a message is received, the program checks if the caller is an authorized CCIP router by validating against the router address stored in this PDA

1.  **Messages Storage PDA**:

        - Contains only the most recent cross-chain message
        - Derived using the seed "messages"
        - Maintains a message counter and last updated timestamp
        - Stores message such as the message ID, type, and data payload

## Implementing Arbitrary Messaging

In this section, we'll examine how arbitrary messaging works in the example script from the starter kit repository. This will help you understand how to send messages to the CCIP Basic Receiver program on Solana Devnet.

### Deriving Program Derived Addresses

The script first derives the PDAs required by the receiver program. This is a critical step because the program can only process messages if the correct PDAs are provided:

```typescript
function deriveReceiverPDAs(receiverProgramIdStr: string) {
  const receiverProgramId = new PublicKey(receiverProgramIdStr)

  const STATE_SEED = Buffer.from("state")
  const MESSAGES_STORAGE_SEED = Buffer.from("messages_storage")

  const [statePda] = PublicKey.findProgramAddressSync([STATE_SEED], receiverProgramId)

  const [messagesStoragePda] = PublicKey.findProgramAddressSync([MESSAGES_STORAGE_SEED], receiverProgramId)

  return {
    state: statePda,
    messagesStorage: messagesStoragePda,
  }
}

// Get the receiver program ID for Solana Devnet
const receiverProgramId = getCCIPSVMConfig(ChainId.SOLANA_DEVNET).receiverProgramId.toString()

// Derive the PDAs for the receiver program
const pdas = deriveReceiverPDAs(receiverProgramId)
```

<Aside type="important" title="PDA Derivation">
  When interacting with any Solana program, PDAs must be derived using the exact same seeds that the program uses
  internally. Incorrect seeds will result in different addresses, causing transaction failures.
</Aside>

### Configuring the Message

The script then configures the CCIP message with all necessary parameters for arbitrary messaging:

```typescript
const MESSAGE_CONFIG = {
  // Custom message to send - must be properly encoded as hex with 0x prefix
  // This example encodes "Hello World" to hex
  data: "0x48656c6c6f20576f726c64", // "Hello World" in hex

  // Destination program on Solana that will receive the message
  receiver: receiverProgramId,

  // Fee token to use for CCIP fees
  feeToken: FeeTokenType.LINK,

  // No tokens are transferred with this message
  tokenAmounts: [],

  // Extra configuration for Solana
  extraArgs: {
    // Compute units for Solana execution
    // Needed because message processing requires compute units
    computeUnits: 200000,

    // Allow out-of-order execution - MUST be true for Solana
    allowOutOfOrderExecution: true,

    // Binary 10 (decimal 2) means only the messages storage account is writable
    accountIsWritableBitmap: BigInt(2),

    // Token receiver - for arbitrary messages, this is usually the default PublicKey
    tokenReceiver: PublicKey.default.toString(),

    // Accounts required by the receiver program
    accounts: [pdas.state.toString(), pdas.messagesStorage.toString()],
  },
}
```

### Understanding AccountIsWritableBitmap

When sending messages to Solana programs, you need to specify which accounts can be written to. The `accountIsWritableBitmap` parameter in the script indicates which accounts in the `accounts` array should be marked as writable.

For our example:

- The script provides 2 accounts: `[statePda, messagesStoragePda]`
- Both accounts need to be writable for the program to update them
- The bitmap calculation works as follows:

<Tabs client:visible>
  <Fragment slot="tab.1">Binary Method</Fragment>
  <Fragment slot="tab.2">Decimal Method</Fragment>
  <Fragment slot="tab.3">Position Values</Fragment>
  <Fragment slot="panel.1">
    **Binary representation of writable accounts**: Position 0 (statePda): Writable → Bit 0 = 1 Position 1
    (messagesStoragePda): Writable → Bit 1 = 1 Binary: 11 = Decimal 3
  </Fragment>
  <Fragment slot="panel.2">
    **Each position has a decimal value**: Position 0: 2^0 = 1 Position 1: 2^1 = 2 Total: 1 + 2 = 3
  </Fragment>
  <Fragment slot="panel.3">
    **Simplified position values**: | Account Position | Decimal Value If Writable |
    |------------------|---------------------------| | 0 | 1 | | 1 | 2 | | 2 | 4 | | 3 | 8 | | 4 | 16 | | 5 | 32 | In
    our case: Position 0 (1) + Position 1 (2) = 3
  </Fragment>
</Tabs>

### Creating and Sending the CCIP Message

Finally, the script creates and sends the CCIP message using the CCIP SDK:

```typescript
// Setup client context
const { client, wallet } = await setupClientContext()

// Create the CCIP message request
const ccipMessageRequest = await createCCIPMessageRequest(client, config.destinationChainSelector, MESSAGE_CONFIG)

// Send the CCIP message
const result = await client.sendCCIPMessage(ccipMessageRequest)
```

This sends the message to the CCIP router, which then forwards it to the Solana program on the destination chain.

## Running the Arbitrary Messaging Script

Now that you understand how the arbitrary messaging script works, let's execute it to send a message:

```bash
npx ts-node ccip-scripts/evm/router/2_arbitrary-messaging.ts
```

### Expected Output

When you run the script, it will display detailed information about the message being sent. You should see output similar to this:

```
[arbitrary-messaging] [INFO] ==== Environment Information ====
[arbitrary-messaging] [INFO] Router Address: 0xFf0614d1c51a89729dfa69bf6f7f8e33f47CEC6C
[arbitrary-messaging] [INFO] Wallet Address: 0x9d087fC03ae39b088326b67fA3C788236645b717
[arbitrary-messaging] [INFO] Native Balance: 3.725785150177999963 ETH

[arbitrary-messaging] [INFO] Creating CCIP message request
[arbitrary-messaging] [INFO] Using fee token: 0x779877A7B0D9E8603169DdbD7836e478b4624789

[arbitrary-messaging] [INFO] ==== Transfer Summary ====
[arbitrary-messaging] [INFO] Source Chain: Ethereum Sepolia
[arbitrary-messaging] [INFO] Destination Chain: Solana Devnet (16423721717087811551)
[arbitrary-messaging] [INFO] Sender: 0x9d087fC03ae39b088326b67fA3C788236645b717
[arbitrary-messaging] [INFO] Receiver: BqmcnLFSbKwyMEgi7VhVeJCis1wW26VySztF34CJrKFq
[arbitrary-messaging] [INFO] Token Receiver: 11111111111111111111111111111111
[arbitrary-messaging] [INFO] Fee Token: 0x779877A7B0D9E8603169DdbD7836e478b4624789
[arbitrary-messaging] [INFO] No tokens being transferred
[arbitrary-messaging] [INFO] Message Data: 0x48656c6c6f20576f726c64
[arbitrary-messaging] [INFO] Message Data (decoded): Hello World
[arbitrary-messaging] [INFO] Extra Args: Solana-specific, 586 bytes
[arbitrary-messaging] [INFO] Additional Accounts: 9XDoTJ5mYNnxqdtWV5dA583VCiGUhmL3oEMWirqys3tF, CB7ptrDkY9EgwqHoJwa3TF8u4rhwYmTob2YqzaSpPMtE
[arbitrary-messaging] [INFO] Account Is Writable Bitmap: 3

[arbitrary-messaging] [INFO] Sending CCIP message...
[ccip-messenger] [INFO] Estimated fee: 4500001834950675
[ccip-messenger] [INFO] Approving 0.00540000220194081 LINK for CCIP Router
[ccip-messenger] [INFO] LINK approved for CCIP Router
[ccip-messenger] [INFO] ✅ Verified onchain allowance for LINK
[ccip-messenger] [INFO] Sending CCIP message...
[ccip-messenger] [INFO] Transaction sent: 0x8c0c0d0e25ce9609480bcf0d24a5ca29828cd7eba8d8027d9965d4a41f2a91b2
[ccip-messenger] [INFO] Message ID: 0xddff06d48acba059d3d6741e9f1ec1c190680340fe4c4b1fee55f572d983eff9

[arbitrary-messaging] [INFO] ==== Transfer Results ====
[arbitrary-messaging] [INFO] Transaction Hash: 0x8c0c0d0e25ce9609480bcf0d24a5ca29828cd7eba8d8027d9965d4a41f2a91b2
[arbitrary-messaging] [INFO] Transaction URL: https://sepolia.etherscan.io/tx/0x8c0c0d0e25ce9609480bcf0d24a5ca29828cd7eba8d8027d9965d4a41f2a91b2
[arbitrary-messaging] [INFO] Message ID: 0xddff06d48acba059d3d6741e9f1ec1c190680340fe4c4b1fee55f572d983eff9
[arbitrary-messaging] [INFO] CCIP Explorer: https://ccip-ui-staging.vercel.app/msg/0xddff06d48acba059d3d6741e9f1ec1c190680340fe4c4b1fee55f572d983eff9
[arbitrary-messaging] [INFO] Destination Chain Selector: 16423721717087811551
[arbitrary-messaging] [INFO] Sequence Number: 498

[arbitrary-messaging] [INFO] Message tracking for Solana destinations:
[arbitrary-messaging] [INFO] Please check the CCIP Explorer link to monitor your message status.
[arbitrary-messaging] [INFO] ✅ Cross-chain transfer completed
```

### Customizing the Message

The script accepts several command-line parameters that let you customize your message:

<Tabs client:visible>
  <Fragment slot="tab.1">Custom Message</Fragment>
  <Fragment slot="tab.2">Custom Compute Units</Fragment>
  <Fragment slot="tab.3">Different Fee Token</Fragment>
  <Fragment slot="panel.1">
    ```bash # Send a custom text message npx ts-node ccip-scripts/evm/router/2_arbitrary-messaging.ts --data "Your
    custom message here" ```
  </Fragment>
  <Fragment slot="panel.2">
    ```bash # Adjust compute units for complex programs npx ts-node ccip-scripts/evm/router/2_arbitrary-messaging.ts
    --compute-units 300000 ```
  </Fragment>
  <Fragment slot="panel.3">
    ```bash # Use native ETH instead of LINK for fees npx ts-node ccip-scripts/evm/router/2_arbitrary-messaging.ts
    --fee-token native ```
  </Fragment>
</Tabs>

## Verification: Retrieving the Message

After sending your message, you'll want to verify that it was received and processed by the receiver program. The CCIP Basic Receiver program stores messages, allowing you to retrieve them:

```bash
npx ts-node ccip-scripts/svm/receiver/get-latest-message.ts
```

### Expected Verification Output

When you run the verification script, you'll see output that confirms your message was received:

```
[2025-04-20T21:49:42.648Z] CCIP Basic Receiver - Get Latest Message
[2025-04-20T21:49:42.651Z] Program ID: BqmcnLFSbKwyMEgi7VhVeJCis1wW26VySztF34CJrKFq
[2025-04-20T21:49:42.651Z] Loading keypair from /Users/aelmanaa/.config/solana/id.json...
[2025-04-20T21:49:42.684Z] Wallet public key: EPUjBP3Xf76K1VKsDSc6GupBWE8uykNksCLJgXZn87CB
[2025-04-20T21:49:42.692Z] Messages Storage PDA: CB7ptrDkY9EgwqHoJwa3TF8u4rhwYmTob2YqzaSpPMtE
[2025-04-20T21:49:43.271Z] Fetching latest message...
[2025-04-20T21:49:43.533Z]
======== LATEST MESSAGE ========
[2025-04-20T21:49:43.534Z] Message ID: 0xddff06d48acba059d3d6741e9f1ec1c190680340fe4c4b1fee55f572d983eff9
[2025-04-20T21:49:43.534Z] Source Chain Selector: 16015286601757825753
[2025-04-20T21:49:43.534Z] Sender: 0x9d087fc03ae39b088326b67fa3c788236645b717
[2025-04-20T21:49:43.534Z] Message Type: Arbitrary Messaging
[2025-04-20T21:49:43.534Z] Received Timestamp: 2025-04-20T19:20:23.000Z
[2025-04-20T21:49:43.534Z] Data (hex): 0x48656c6c6f20576f726c64
[2025-04-20T21:49:43.534Z] Data (text): Hello World
[2025-04-20T21:49:43.534Z] No tokens transferred in this message
```

<Aside type="tip" title="Verifying Message Details">
  In the output, check that: - The **Message ID** matches the one from your arbitrary messaging script - The **Source
  Chain Selector** indicates Ethereum Sepolia (16015286601757825753) - The **Sender** matches your EVM wallet address -
  The **Data** shows your message correctly decoded
</Aside>

<Aside type="note" title="Processing Time">
  Cross-chain messages are not instant. It may take several minutes for your message to be processed on the destination
  chain, especially during network congestion.
</Aside>

## How It Works: Behind the Scenes

When you send an arbitrary message from Ethereum to Solana:

1. **Source Chain Actions**:

   - The sender approves the CCIP router to spend fee tokens (LINK)
   - The CCIP message is sent to the router contract with the program ID as the receiver

2. **CCIP Network Processing**:

   - CCIP validators observe the message on the source chain
   - They reach consensus on the message data
   - They execute the message on the destination chain

3. **Destination Chain Actions**:
   - The CCIP Offramp program on Solana calls the receiver program
   - The receiver program processes the message data
   - The program updates its state and message storage PDAs
   - The compute units specified in the message are consumed during execution

<ClickToZoom
  src="/images/ccip/evm_solana_arbitrary_message_execution.jpg"
  alt="Arbitrary message execution flow on Solana"
  style="display: block; margin: 0 auto; max-width: 100%; height: auto;"
/>

## Common Issues and Troubleshooting

Here are some common issues you might encounter and how to resolve them:

| Issue                      | Possible Cause                           | Solution                                                   |
| -------------------------- | ---------------------------------------- | ---------------------------------------------------------- |
| Insufficient funds         | Not enough ETH for gas                   | Add more ETH to your wallet                                |
| Insufficient fee tokens    | Not enough LINK for CCIP fees            | Get more LINK from the faucet                              |
| Transaction reverted       | Incorrect PDAs or bitmap                 | Verify your PDAs and bitmap calculation                    |
| Out of compute units       | Complex program logic needs more compute | Increase `computeUnits` parameter                          |
| Message not received       | Patience needed                          | CCIP transfers can take several minutes to finalize        |
| Error in program execution | Incorrect message format                 | Ensure data is properly formatted for the receiver program |

## Advanced: Sending to Custom Programs

While this tutorial uses the CCIP Basic Receiver program, the same principles apply to any Solana program that implements the CCIP receiver interface:

1. **Identify the program ID** of your target Solana program
2. **Derive the correct PDAs** required by your program
3. **Set the appropriate `accountIsWritableBitmap`** based on which PDAs need to be written to
4. **Format your data** according to your program's expected format
5. **Set sufficient `computeUnits`** based on your program's complexity

<Aside type="tip" title="Custom Program Requirements">
  When developing your own CCIP-compatible Solana program: - Implement the `ccip_receive` function - Define clear
  account structures - Document required PDAs and their derivation - Set appropriate access controls
</Aside>

## Next Steps

Now that you've completed this tutorial, you can explore more advanced CCIP functionality:

1. [Sending tokens and data in a single message](/ccip/tutorials/evm-to-solana-combined-messaging)
2. [Implementing a CCIP receiver program on Solana](/ccip/tutorials/solana-ccip-receiver)
3. [Building a cross-chain dApp with arbitrary messaging](/ccip/tutorials/cross-chain-dapp)

<CcipCommon callout="educationalDisclaimer" />
