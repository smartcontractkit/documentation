---
section: ccip
date: Last Modified
title: "Cross Chain Tokens (CCT) Standard"
whatsnext: { "CCT Guides": "/ccip/tutorials/cross-chain-tokens" }
---

import { Aside, ClickToZoom } from "@components"

Cross Chain Tokens (CCT) Standard offers a streamlined and decentralized approach to enabling token transfers across blockchains using Chainlink's Cross Chain Interoperability Protocol (CCIP). Traditionally, token issuers had to work directly with Chainlink Labs to enable their tokens for cross-chain operations. This process required manual engagement, deployment of token pools, and management support from Chainlink Labs, making it time-consuming and dependent on Chainlink Labs intervention.
With the introduction of CCT, projects now have the power to deploy, configure, and manage their token pools in CCIP without requiring direct involvement from Chainlink Labs. This self-service model not only accelerates the deployment process but also empowers token issuers with greater autonomy and control over their cross-chain token operations.
This guide will explore the motivations behind Cross Chain Tokens (CCT) and provide an overview of the architectural components in enabling an [ERC20-compatible](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/) token in CCIP.

## Motivations

The motivation for Cross Chain Tokens (CCT) originates from two primary challenges: liquidity fragmentation in a multi-chain ecosystem and the need for greater autonomy for token issuers.

- **Liquidity Fragmentation**: More than [hundreds](https://chainlist.org/) of blockchains exist, each with its own rules, consensus mechanisms, and liquidity. This expansion has created fragmented liquidity, where assets are siloed on individual blockchains, making it difficult for users and developers to access liquidity across different ecosystems. Token issuers face the dilemma of choosing which blockchain to deploy on, often deciding between the blockchain with the most liquidity or a new, emerging chain with future potential. Each decision comes with risks, such as competing in a crowded market or dealing with trust assumptions on new blockchains.

- **Need for Greater Autonomy**: Another critical motivation behind Cross Chain Tokens is to empower projects to enable their tokens for cross-chain operations without requiring direct intervention from Chainlink Labs. Previously, projects were dependent on Chainlink Labs for deploying token pools and managing token pools, including configuring supported lanes and specifying [rate limits](/ccip/architecture#token-pool-rate-limit). This dependency introduced complexity, caused delays, and added overhead to deployment. By providing a self-service model, Cross Chain Tokens allow projects to take control of their cross-chain applications. This enables rapid expansion to other blockchains supported by CCIP.

Cross Chain Tokens (CCT) solve these challenges by allowing token issuers to create assets that can move seamlessly across multiple blockchains without fragmenting liquidity. By deploying a token in multiple blockchain environments, token issuers can maintain a consistent supply, manage liquidity efficiently, and reach users on different blockchains without introducing complex bridging processes. The CCT Standard offers the following benefits:

- **Self-service and Permissionless Deployment**: With CCT, token issuers can launch a cross-chain token or upgrade an existing token in a self-service manner within minutes. The fully audited token pool contracts handle the complexities of burning/minting or locking/minting tokens across blockchains, all without requiring liquidity pools. This enables a streamlined and permissionless deployment process that significantly reduces the barriers to cross-chain expansion.

- **Issuer Control and Flexibility**: Token issuers retain complete ownership of their token contracts, token pools, and implementation logic. This includes configuring [rate limits](/ccip/architecture#token-pool-rate-limit) across all blockchains, ensuring that token issuers have full autonomy to manage their deployments. The CCT standard avoids vendor lock-in, hard-coded functions, and external dependencies, giving projects the flexibility they need to succeed.

- **Defense-in-Depth Security**: The CCT standard leverages Chainlink's industry-standard oracle networks, which secure over $16 trillion in Total Value Enabled (TVE). This strong foundation is further enhanced by additional layers of protection, such as the [Risk Management Network](/ccip/concepts#risk-management-network) and configurable transfer [rate limits](/ccip/architecture#token-pool-rate-limit), providing comprehensive security for cross-chain operations.

- **Programmable Token Transfers**: Cross Chain Tokens support the simultaneous transfer of tokens and messages in a single transaction. This programmability allows for complex use cases, such as executing on-chain actions alongside token transfers, improving the overall efficiency of cross-chain transactions. For instance, a programmable token transfer could execute a function to stake tokens on the destination blockchain.

- **No Liquidity Pools Required**: The fully audited token pool contracts provided by CCT eliminate the need for liquidity pools, simplifying cross-chain token management. By locking or burning tokens on the source chain and minting or unlocking them on the destination chain, token issuers can maintain consistent liquidity without managing fragmented liquidity pools across multiple blockchains.

- **Reduced Liquidity Fragmentation**: The CCT standard addresses liquidity fragmentation by allowing tokens to move seamlessly across multiple blockchains. This unified approach ensures that liquidity remains consistent and accessible across all supported blockchains, reducing inefficiencies and improving the user experience.

- **Ease of Upgradability**: With CCT, existing tokens can be easily upgraded to support cross-chain functionality without requiring complete redeployment. This makes it possible for token issuers to extend their token's reach across multiple blockchains with minimal effort, avoiding the complexities associated with traditional bridging solutions.

## Key Terms and Concepts

- **Token Issuer**: The entity responsible for issuing and managing the token. Token issuers decide which blockchains to deploy the token on, manage its lifecycle, and control its availability across different networks.

- **Token Owner**: The entity that owns the token contract. The token owner has the authority to manage the token contract, including upgrading the contract, changing the token administrator, or transferring ownership to another address.

- **Token Administrator**: A role assigned to manage cross-chain operations of a token. The token administrator is responsible for setting up token pools, configuring cross-chain parameters, such as supported lanes or token pool [rate limits](/ccip/architecture#token-pool-rate-limit). The token administrator can be the token owner or another designated entity assigned by the token owner. Technically, the token administrator can be an EOA or a smart account.

- **EOA (Externally Owned Account)**: A standard blockchain account controlled by a private key, typically used by individuals. EOAs do not have associated code, unlike smart accounts, and are used for directly signing transactions.

- **Smart Account**: A blockchain account represented by a smart contract, offering advanced functionality like multi-signature authorization or custom transaction logic. Smart accounts provide better security and flexibility compared to EOAs. For example, smart accounts can use multi-signature mechanisms to add an extra layer of security.

- **ERC20-Compatible Token**: A token that adheres to the [ERC20 token](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/) or any other token standard that improves upon it, such as [ERC677](https://github.com/ethereum/EIPs/issues/677) or [ERC777](https://ethereum.org/en/developers/docs/standards/tokens/erc-777/). These contracts have the same interface as ERC20 but add extra functionalities. Cross Chain Tokens need to be ERC20-compatible to ensure interoperability across different blockchain ecosystems. The specific requirements for ERC20-compatible tokens in CCIP will be detailed [later](#requirements-for-erc20-compatible-tokens) in this document, including requirements for Burn & Mint and Lock & Mint mechanisms.

- **Token Pool**: Each token is associated with its own token pool, which acts as abstraction layer over ERC-20 tokens designed to facilitate token-related operations for OnRamping and OffRamping. Token pools provide [rate limits](/ccip/architecture#token-pool-rate-limit), a security feature enabling token issuers to set a maximum rate at which their token can be transferred per lane. Token pools are configured to `lock` or `burn` tokens on the source blockchain and `unlock` or `mint` tokens on the destination blockchain. This setup results in four primary mechanisms:

  - **Burn and Mint**: Tokens are burned on the source blockchain, and an equivalent amount of tokens are minted on the destination blockchain. This keeps the total supply of the token constant across blockchains.

        <ClickToZoom
            src="/images/ccip/cct/handling/burn-mint.jpeg"
            alt="Burn and Mint"
        />

  - **Lock and Mint**: This mechanism is suitable for projects with existing tokens on a single blockchain that have already been minted and lack functionality to control the supply via `burn` and `mint` functions on the source blockchain. In this approach, tokens are locked on the issuing blockchain, and fully collateralized "wrapped" tokens are minted on the destination blockchain. These wrapped tokens, which must support `burn` and `mint` functionality, can subsequently be transferred across other non-issuing blockchains using the Burn and Mint mechanism.

          <ClickToZoom
            src="/images/ccip/cct/handling/lock-mint.jpeg"
            alt="Lock and Mint"
        />

  - **Burn and Unlock**: Tokens are burned on the source blockchain (which is the non-issuing blockchain), and an equivalent amount of tokens are released on the destination blockchain (the issuing blockchain). This mechanism is the inverse of the Lock and Mint mechanism and applies when you send tokens back to their issuing source blockchain.

          <ClickToZoom
            src="/images/ccip/cct/handling/burn-unlock.jpeg"
            alt="Burn and Unlock"
        />

  - **Lock and Unlock**: Tokens are locked on the source blockchain, and an equivalent amount of tokens are released on the destination blockchain. This use case should be rare and is generally **discouraged**, as it implies multiple issuing blockchains, which results in fragmented liquidity.

            <ClickToZoom
            src="/images/ccip/cct/handling/lock-unlock.jpeg"
            alt="Lock and Unlock"
        />

## Requirements for ERC20-Compatible Tokens

Before enabling an ERC20-compatible token in CCIP, it's important to understand the requirements it must fulfill to integrate with CCIP.

- **Token Administrator address requirement**: The token contract must provide an easy way to obtain the token administrator address. This can be achieved if the token contract includes one of the following functions:

  - `owner()`: This function returns the token contract owner's address.
  - `getCCIPAdmin()`: This function returns the token administrator's address if it differs from the contract owner's.

- **Requirements for CCIP token transfers**: The token's smart contract must meet minimum requirements to integrate with CCIP.

  - **Burn & Mint Requirements**:
    - The token smart contract must have the following functions:
      - `mint(address account, uint256 amount)`: This function is used to mint the `amount` of tokens to a given `account` on the destination blockchain.
      - `burn(uint256 amount)`: This function is used to burn the `amount` of tokens on the source blockchain.
      - `decimals()`: Returns the token's number of decimals.
    - On the source and destination blockchains, the token contract must support granting mint and burn permissions. The token issuers or another role (such as the token administrator) will grant these permissions to the token pool.
  - **Lock & Mint Requirements**:
    - The token smart contract must have the following function:
      - `decimals()`: Returns the token's number of decimals.
    - On the destination blockchain, The token contract must support granting mint and burn permissions. The token issuers or another role (such as the token administrator) will grant these permissions to the token pool.

If you don't have an existing token: For all blockchains where tokens need to be burned and minted (for example, the source or destination chain in the case of Burn and Mint, or the destination blockchain in the case of Lock and Mint), Chainlink provides a [BurnMintERC677](https://github.com/smartcontractkit/ccip/blob/ccip-develop/contracts/src/v0.8/shared/token/ERC677/BurnMintERC677.sol) contract that you can use to deploy your token in minutes. This token follows the [ERC677](https://github.com/ethereum/EIPs/issues/677) or [ERC777](https://ethereum.org/en/developers/docs/standards/tokens/erc-777/), allowing you to use it as-is or extend it to meet your specific requirements.

## Requirement for Token Pools

### Standard Token Pools

Depending on your use case (token handling mechanism), you need to deploy the appropriate token pool type for each blockchain you want to support.

When CCIP interacts with your token pools, it expects the presence of the following functions:

- **Source Blockchain**: This must include the following function:

  - `lockOrBurn(Pool.LockOrBurnInV1 calldata lockOrBurnIn) external returns (Pool.LockOrBurnOutV1 memory)`: This function locks or burns tokens on the source blockchain. Refer to the [`Pool`](/ccip/api-reference/pool) library API reference for details about the input and output parameters.

- **Destination Blockchain**: This must include the following function:
  - `releaseOrMint(Pool.ReleaseOrMintInV1 calldata releaseOrMintIn) external returns (Pool.ReleaseOrMintOutV1 memory)`: This function releases or mints tokens on the destination blockchain. Refer to the [`Pool`](/ccip/api-reference/pool) library API reference for details about the input and output parameters.

Chainlink provides a set of token pool contracts that you can use to deploy your token pools in minutes. These token pools are fully audited and ready for deployment on your blockchains. You can find the token pool contracts in the [Chainlink GitHub repository](https://github.com/smartcontractkit/ccip/tree/ccip-develop/contracts/src/v0.8/ccip/pools). For most use cases, you can use:

- [BurnMintTokenPool](https://github.com/smartcontractkit/ccip/blob/ccip-develop/contracts/src/v0.8/ccip/pools/BurnMintTokenPool.sol): This token pool is used to burn or mint tokens. You can read the API reference [here](/ccip/api-reference/burn-mint-token-pool).
- [LockReleaseTokenPool](https://github.com/smartcontractkit/ccip/blob/ccip-develop/contracts/src/v0.8/ccip/pools/LockReleaseTokenPool.sol): This token pool is used to lock or release tokens. You can read the API reference [here](/ccip/api-reference/lock-release-token-pool).

**Note**: Both token pools inherit from the same base [TokenPool](https://github.com/smartcontractkit/ccip/blob/ccip-develop/contracts/src/v0.8/ccip/pools/TokenPool.sol) contract, which provides all the common functions necessary for a token pool. For example, it includes the [`applyChainUpdates`](/ccip/api-reference/token-pool#applychainupdates) function, which is used to configure the token pool. You can read the API reference [here](/ccip/api-reference/token-pool).

### Token Handling Mechanisms and Token Pool Deployment

To facilitate cross-chain token transfers, you need to choose the appropriate token handling mechanism and deploy the correct combination of token pools for the source and destination blockchains. The table below summarizes the different token handling mechanisms and the recommended token pools to deploy for each scenario, ensuring a seamless token transfer process.

| Token Handling Mechanism | Source Blockchain Token Pool | Destination Blockchain Token Pool | Notes                                                                                                                                                                                                           |
| ------------------------ | ---------------------------- | --------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Burn and Mint            | BurnMintTokenPool            | BurnMintTokenPool                 | - Standard burn and mint mechanism for cross-chain token transfers.                                                                                                                                             |
| Lock and Mint            | LockReleaseTokenPool         | BurnMintTokenPool                 | - The source blockchain is the issuing blockchain. <br/> - LockReleaseTokenPool **must** be deployed on the issuing blockchain.                                                                                 |
| Burn and Unlock          | BurnMintTokenPool            | LockReleaseTokenPool              | - The destination blockchain is the issuing blockchain. <br/> - BurnMintTokenPool is used to burn tokens on the source blockchain, and LockReleaseTokenPool is used to unlock tokens on the issuing blockchain. |

### Custom Token Pools

If the standard token pools do not meet your requirements, you have the option to build a custom TokenPool. However, it is essential to adhere to the following guidelines:

- Your custom TokenPool must inherit from the base token pool contract and implement the mandatory functions for both the source and destination blockchains. (Refer to the [Standard Token Pools](#standard-token-pools) section for more details.)

- A critical aspect to consider for custom token pools is the **reception logic** on the destination blockchain. Specifically, the `releaseOrMint` function should not consume more than **90,000 gas**. If this limit is exceeded, the CCIP execution on the destination blockchain will fail, requiring manual intervention by the user to execute the transaction. For more information, see [Manual execution](/ccip/concepts/manual-execution).

- If your token pool requires more than **90,000** gas on the destination blockchain, you should contact Chainlink Labs to update an internal CCIP parameter to avoid execution failure. It is highly recommended to design your custom TokenPool to stay within the 90,000 gas limit whenever possible.

Here are some examples of use cases that may require custom token pools:

- **Tokens with different decimals across blockchains**:

  - **Use Case**: Some tokens have different decimal values across various blockchains.
  - **Solution**:

    - **Source Blockchain**: During the lock or burn process on the source blockchain, the TokenPool should include a shared denomination in the `destPoolData` field of the [`LockOrBurnOutV1`](/ccip/api-reference/pool#lockorburnoutv1) struct (returned by the `lockOrBurn` function) to represent the value in a standard format. This data is then passed to the destination blockchain via CCIP.
    - **Destination Blockchain**: On the destination blockchain, the TokenPool should use the information contained in the `sourcePoolData` of the [`ReleaseOrMintInV1`](/ccip/api-reference/pool#releaseormintinv1) struct (used by the `releaseOrMint` function) to convert the value into the local denomination. The correct number of tokens should then be minted based on the destination blockchain's decimal format. The minted amount is returned in the `destinationAmount` field of the [`ReleaseOrMintOutV1`](/ccip/api-reference/pool#releaseormintoutv1) struct, which is returned by the `releaseOrMint` function.

- **Tokens with rebasing**:

  - **Use Case**: Rebasing tokens are a unique type of token that adjusts its supply in response to specific parameters (e.g., price). These tokens require custom logic to handle rebasing events during cross-chain transfers.
  - **Solution**:
    - **Source Blockchain**: When initiating a cross-chain transfer of rebasing tokens, the TokenPool on the source blockchain should lock or burn the underlying shares rather than a fixed amount of tokens. This ensures that the value is consistently represented, regardless of changes in supply. The number of shares being locked or burned is recorded in the [`destPoolData`](/ccip/api-reference/pool#lockorburnoutv1) and passed to the destination blockchain.
    - **Destination Blockchain**: On the destination blockchain, the TokenPool should accurately convert the number of underlying shares to tokens using the current share-to-token ratio. The calculated token amount should then be minted on the destination blockchain and returned in the `destinationAmount` field of the [`ReleaseOrMintOutV1`](/ccip/api-reference/pool#releaseormintoutv1) struct, which is returned by the `releaseOrMint` function.

## CCT Architecture Overview

<Aside type="note" title="Prerequisites">
  Before proceeding, ensure you are familiar with the key [CCIP Concepts](/ccip/concepts) and the general [CCIP
  Architecture](/ccip/architecture). This knowledge is essential for understanding how CCIP works.
</Aside>

The Cross Chain Tokens (CCT) architecture offers a streamlined, self-service approach to enabling cross-chain operations. This system integrates tightly with Chainlink's Cross Chain Interoperability Protocol (CCIP), allowing token issuers to configure, manage, and transfer tokens across multiple blockchains without requiring direct involvement from Chainlink Labs.

### Architectural

The detailed architecture diagram below provides a comprehensive view of how CCT fits within the CCIP ecosystem, illustrating the interaction between key components such as token contracts, token pools, and registry modules. While you can explore the full details of these components in the [CCIP Architecture](/ccip/architecture) document, the key takeaway for Cross Chain Tokens (CCT) is understanding how the **TokenAdminRegistry** contract is used.

<ClickToZoom src="/images/ccip/CCIP_detailed_architecture_1.5.png" alt="Chainlink CCIP Detailed Architecture 1.5" />

The **TokenAdminRegistry** contract is essential when transferring tokens across blockchains. CCIP's [`onRamp`](/ccip/architecture#onramp) and [`offRamp`](/ccip/architecture#offramp) contracts interact with it to fetch the token pool associated with a given token. For cross-chain transfers to work, token administrators need a way to set or configure the token pool linked to a token.

In the following sections, we will explore how token administrators can register their tokens in the TokenAdminRegistry, link them to the relevant token pools, and configure them for use in CCIP.

### Key Contracts

In the Cross Chain Tokens (CCT) standard, several key contracts work together to facilitate the secure transfer and management of tokens across multiple blockchains. These contracts can be categorized into three main groups:

#### Registry Components

The **Registry Components** manage the registration tokens within the CCT system. They ensure that the correct entities have control over cross-chain operations.

- [`TokenAdminRegistry`](/ccip/api-reference/token-admin-registry): This contract stores the token administrators and pools for all registered Cross Chain Tokens. It allows tokens to be registered in a self-service manner and handles administrator role changes via a two-step process (transfer request and acceptance).
- [`RegistryModuleOwnerCustom`](/ccip/api-reference/registry-module-owner-custom): This contract facilitates the registration of token administrators. It works with the **TokenAdminRegistry** to ensure that only authorized administrators are assigned to manage cross-chain operations.

#### Token Contract

The **Token Contract** represents the actual token being managed and transferred across blockchains. This contract must be **ERC20-compatible** and have additional functionalities depending on the cross-chain handling mechanism used. For more details on the requirements for ERC20-compatible tokens, refer to the [Requirements for ERC20-Compatible Tokens](#requirements-for-erc20-compatible-tokens) section.

#### Token Pool Contract

The **Token Pool Contract** is responsible for executing the cross-chain token transfers. It manages how tokens are locked, burned, minted, or unlocked across blockchains.

- **Token Pools**: Each blockchain has its own token pool that interacts with the token contract. Depending on the cross-chain handling mechanism (e.g., Burn & Mint or Lock & Mint), different token pool contracts will be deployed. For example:
  - **BurnMintTokenPool**: Handles the burning, or minting of tokens depending whether it is the source or destination blockchain.
  - **LockReleaseTokenPool**: Handles the locking or releasing of tokens depending on whether it is the source or destination blockchain.

For more information on the token pool contracts and their functionalities, refer to the [Requirement for Token Pools](#requirement-for-token-pools) section.

### Registration

The process of registering your token for **Cross Chain Tokens (CCT)** involves a **two-step process** to ensure that the correct administrator is assigned. Whether the registration happens via the **self-service** method or through **Chainlink Labs intervention**, the token's administrator will initially be placed in a pending state. The administrator must then explicitly accept the role to complete the registration.

#### Self-Service Registration Flow

If the token contract includes the necessary functions (`getCCIPAdmin()` or `owner()`), the registration can be done autonomously by the token administrator:

1. **Admin Initiates Registration**: The token administrator begins the process by calling either the `registerAdminViaGetCCIPAdmin()` or `registerAdminViaOwner()` function on the **RegistryModuleOwnerCustom** contract.
1. **Determine Administrator**: The **RegistryModuleOwnerCustom** contract retrieves the administrator from the token contract using the appropriate method (`getCCIPAdmin()` or `owner()`).

1. **Propose Administrator**: The retrieved administrator is then proposed to the **TokenAdminRegistry** using the `proposeAdministrator()` function, placing the administrator in a pending state.

1. **Pending Administrator**: At this point, the administrator is marked as "pending" in the `TokenAdminRegistry` and must complete the second step—**accepting the role**—before being officially assigned.

#### Non-Self-Service Registration Flow

If the token contract does not have the necessary functions (`getCCIPAdmin()` or `owner()`), the token issuer must manually initiate the registration:

1. **Contact Chainlink Labs**: The token issuer needs to contact Chainlink Labs to verify and register the token manually.

1. **Verification**: Chainlink Labs will verify the information provided. If additional details are required, they will contact the token issuer for clarification.

1. **Inform CCIP Contracts Owner**: Once Chainlink Labs confirms that the information is valid and correct, they will inform the [CCIP contracts owner](/ccip/architecture#implementation-process) to propose the administrator through the **TokenAdminRegistry**, placing the administrator in a pending state.

1. **Pending Administrator**: Similar to the self-service flow, the administrator remains in a pending state and must accept the role before finalizing the registration.

#### Sequence Diagram: Proposing the Administrator

The following sequence diagram illustrates the process of proposing the administrator for both self-service and manual registration flows:

          <ClickToZoom
            src="/images/ccip/cct/registration-sequence-diagram.svg"
            alt="Propose administrator sequence diagram"
        />

### Accepting the Administrator Role

Once the administrator has been proposed and is in a pending state, they must accept the role to complete the registration process. This step finalizes the assignment of the administrator.

1. **Administrator Accepts Role**: The pending administrator must explicitly call the `acceptAdminRole()` function on the **TokenAdminRegistry** to complete the registration.
1. **Finalize Registration**: Once the administrator accepts the role, they are assigned as the token administrator, and the registration process is complete. At this point, the token administrator can set a token pool for the token in the **TokenAdminRegistry**.

Once the administrator has been proposed and is in a pending state, the final step in the registration process is for the pending administrator to accept the role. This sequence diagram illustrates how the pending administrator interacts with the **TokenAdminRegistry** to complete the registration. It also covers the scenario where an incorrect entity attempts to accept the role, leading to an error.

          <ClickToZoom
            src="/images/ccip/cct/acceptAdminRole.svg"
            alt="Accept administrator role sequence diagram"
        />

### Transfer Administrator Role

The `transferAdminRole` function allows the current token administrator to initiate the transfer of their role to a new administrator. The transfer process is a secure two-step procedure, requiring the new administrator to explicitly accept the role before the transfer is finalized.

1. **Initiate Role Transfer**: The current administrator calls the `transferAdminRole()` function on the **TokenAdminRegistry**, specifying the token address and the new administrator’s address.
1. **Set Pending Administrator**: The **TokenAdminRegistry** contract verifies that the caller is the current administrator of the token and sets the new administrator as **pending**. The role will remain in this pending state until it is accepted.
1. **Accept the Role**: The new administrator must call the `acceptAdminRole()` function to finalize the transfer and assume the administrator role.

The following sequence diagram illustrates the process of transferring the administrator role and how the new administrator must accept the role to complete the transfer.

<ClickToZoom src="/images/ccip/cct/transferAdminRole.svg" alt="Transfer administrator role sequence diagram" />

### Setting the Token Pool

The `setPool` function allows the token administrator to assign or update the token pool for a specific token in the **TokenAdminRegistry**.

1. **Set Token Pool**: The current administrator calls the `setPool()` function on the **TokenAdminRegistry**, providing the token address and the new pool address.
1. **Validate Pool**: If the new pool address is not `address(0)`, the contract validates that the provided pool supports the token by calling `isSupportedToken()` on the pool contract.
1. **Update or Remove Pool**: If validation succeeds, the token’s pool is updated in the registry. Setting the pool to `address(0)` effectively delists the token from cross-chain operations.

The sequence diagram below shows how the token administrator sets or updates the pool for a token. If the pool is set to `address(0)`, the token is delisted from cross-chain operations.

<ClickToZoom src="/images/ccip/cct/setPool.svg" alt="Set token pool sequence diagram" />

### Configuring the Token Pool

The configuration of token pools includes adding new blockchains, setting remote pool addresses, and applying rate limits for cross-chain transfers. The following functions from the [`TokenPool`](/ccip/api-reference/token-pool) contract are used for configuring token pools:

1. [`applyChainUpdates`](/ccip/api-reference/token-pool#applychainupdates):
   - **Purpose**: This function is the primary method for configuring which blockchains the token pool supports and defining rate limits for cross-chain transfers.
   - **Details**:
     - It allows the token pool owner to add new chains or remove existing ones.
     - Configures the pool and token addresses for remote blockchains.
     - Sets rate limits for both outbound and inbound transfers.
   - **Usage**:
     - To add a new blockchain, the pool owner provides the remote chain selector, pool address, token address, and rate limiter configurations.
     - To remove a blockchain, the `allowed` flag is set to `false`, and the chain is removed from the list of supported chains.
1. [`setRemotePool`](/ccip/api-reference/token-pool#setremotepool)\*\*:

   - **Purpose**: Set the remote pool's address to link the current token pool to a corresponding pool on a remote blockchain.
   - **Details**:
     - This function is used to establish the connection between token pools on different blockchains.
     - It validates the provided chain selector and updates the remote pool address for the selected chain.
   - **Usage**: This function sets or updates the remote pool address for a specific blockchain.

1. [`setChainRateLimiterConfig`](/ccip/api-reference/token-pool#setchainratelimiterconfig)\*\*

   - **Purpose**: Configures the rate limits for outbound and inbound token transfers between blockchains.
   - **Details**:
     - The outbound rate limiter config controls how many tokens can be transferred out of the token pool per unit of time.
     - The inbound rate limiter config limits how many tokens can be transferred into the token pool per unit of time.
     - Only the pool owner or rate limit admin can call this function.
   - **Usage**: This function adjusts rate limits to prevent excessive token transfers or overload of the token pool. **Note**: This function also supports disabling rate limits.

1. [`applyAllowListUpdates`](/ccip/api-reference/token-pool#applyallowlistupdates):
   - **Purpose**: Manages an allowlist of addresses permitted to interact with the token pool.
   - **Details**:
     - This function is only relevant if the token pool is access-controlled (i.e., an allowlist is enabled).
     - The allowlist ensures that only specific addresses, such as trusted addresses, can transfer tokens.
   - **Usage**: The pool owner uses this function to add or remove addresses from the allowlist, controlling who can transfer the tokens through CCIP.
