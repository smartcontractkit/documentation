---
section: ccip
date: Last Modified
title: "Cross Chain Tokens (CCT) Standard"
---

import { Aside, ClickToZoom } from "@components"

Cross Chain Tokens (CCT) Standard offers a streamlined and decentralized approach to enabling token transfers across blockchains using Chainlink's Cross Chain Interoperability Protocol (CCIP). Traditionally, token issuers had to work directly with Chainlink Labs to enable their tokens for cross-chain operations. This process required manual engagement, deployment of token pools, and management support from Chainlink Labs, making it time-consuming and dependent on Chainlink Labs intervention.
With the introduction of CCT, projects now have the power to deploy, configure, and manage their token pools in CCIP without requiring direct involvement from Chainlink Labs. This self-service model not only accelerates the deployment process but also empowers token issuers with greater autonomy and control over their cross-chain token operations.
This guide will explore the motivations behind Cross Chain Tokens (CCT) and provide an overview of the architectural components in enabling an [ERC20-compatible](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/) token in CCIP.

## Motivations

The motivation for Cross Chain Tokens (CCT) originates from two primary challenges: liquidity fragmentation in a multi-chain ecosystem and the need for greater autonomy for token issuers.

- **Liquidity Fragmentation**: More than [hundreds](https://chainlist.org/) of blockchains exist, each with its own rules, consensus mechanisms, and liquidity. This expansion has created fragmented liquidity, where assets are siloed on individual blockchains, making it difficult for users and developers to access liquidity across different ecosystems. Token issuers face the dilemma of choosing which blockchain to deploy on, often deciding between the blockchain with the most liquidity or a new, emerging chain with future potential. Each decision comes with risks, such as competing in a crowded market or dealing with trust assumptions on new blockchains.

- **Need for Greater Autonomy**: Another critical motivation behind Cross Chain Tokens is to empower projects to enable their tokens for cross-chain operations without requiring direct intervention from Chainlink Labs. Previously, projects were dependent on Chainlink Labs for deploying token pools and managing token pools, including configuring supported lanes and specifying [rate limits](/ccip/architecture#token-pool-rate-limit). This dependency introduced complexity, caused delays, and added overhead to deployment. By providing a self-service model, Cross Chain Tokens allow projects to take control of their cross-chain applications. This enables rapid expansion to other blockchains supported by CCIP.

Cross Chain Tokens (CCT) solve these challenges by allowing token issuers to create assets that can move seamlessly across multiple blockchains without fragmenting liquidity. By deploying a token in multiple blockchain environments, token issuers can maintain a consistent supply, manage liquidity efficiently, and reach users on different blockchains without introducing complex bridging processes. The CCT Standard offers the following benefits:

- **Self-service and Permissionless Deployment**: With CCT, token issuers can launch a cross-chain token or upgrade an existing token in a self-service manner within minutes. The fully audited token pool contracts handle the complexities of burning/minting or locking/minting tokens across blockchains, all without requiring liquidity pools. This enables a streamlined and permissionless deployment process that significantly reduces the barriers to cross-chain expansion.

- **Issuer Control and Flexibility**: Token issuers retain complete ownership of their token contracts, token pools, and implementation logic. This includes configuring [rate limits](/ccip/architecture#token-pool-rate-limit) across all blockchains, ensuring that token issuers have full autonomy to manage their deployments. The CCT standard avoids vendor lock-in, hard-coded functions, and external dependencies, giving projects the flexibility they need to succeed.

- **Defense-in-Depth Security**: The CCT standard leverages Chainlink's industry-standard oracle networks, which secure over $16 trillion in Total Value Enabled (TVE). This strong foundation is further enhanced by additional layers of protection, such as the [Risk Management Network](/ccip/concepts#risk-management-network) and configurable transfer [rate limits](/ccip/architecture#token-pool-rate-limit), providing comprehensive security for cross-chain operations.

- **Programmable Token Transfers**: Cross Chain Tokens support the simultaneous transfer of tokens and messages in a single transaction. This programmability allows for complex use cases, such as executing on-chain actions alongside token transfers, improving the overall efficiency of cross-chain transactions. For instance, a programmable token transfer could execute a function to stake tokens on the destination blockchain.

- **No Liquidity Pools Required**: The fully audited token pool contracts provided by CCT eliminate the need for liquidity pools, simplifying cross-chain token management. By locking or burning tokens on the source chain and minting or unlocking them on the destination chain, token issuers can maintain consistent liquidity without managing fragmented liquidity pools across multiple blockchains.

- **Reduced Liquidity Fragmentation**: The CCT standard addresses liquidity fragmentation by allowing tokens to move seamlessly across multiple blockchains. This unified approach ensures that liquidity remains consistent and accessible across all supported blockchains, reducing inefficiencies and improving the user experience.

- **Ease of Upgradability**: With CCT, existing tokens can be easily upgraded to support cross-chain functionality without requiring complete redeployment. This makes it possible for token issuers to extend their token's reach across multiple blockchains with minimal effort, avoiding the complexities associated with traditional bridging solutions.

## Key Terms and Concepts

- **Token Issuer**: The entity responsible for issuing and managing the token. Token issuers decide which blockchains to deploy the token on, manage its lifecycle, and control its availability across different networks.

- **Token Owner**: The entity that owns the token contract. The token owner has the authority to manage the token contract, including upgrading the contract, changing the token administrator, or transferring ownership to another address.

- **Token Administrator**: A role assigned to manage cross-chain operations of a token. The token administrator is responsible for setting up token pools, configuring cross-chain parameters, such as supported lanes or token pool [rate limits](/ccip/architecture#token-pool-rate-limit). The token administrator can be the token owner or another designated entity assigned by the token owner.

- **EOA (Externally Owned Account)**: A standard blockchain account controlled by a private key, typically used by individuals. EOAs do not have associated code, unlike smart accounts, and are used for directly signing transactions.

- **Smart Account**: A blockchain account represented by a smart contract, offering advanced functionality like multi-signature authorization or custom transaction logic. Smart accounts provide better security and flexibility compared to EOAs. For example, smart accounts can use multi-signature mechanisms to add an extra layer of security.

- **ERC20-Compatible Token**: A token that adheres to the [ERC20 token](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/) or any other token standard that improves upon it, such as [ERC677](https://github.com/ethereum/EIPs/issues/677) or [ERC777](https://ethereum.org/en/developers/docs/standards/tokens/erc-777/). These contracts have the same interface as ERC20 but add extra functionalities. Cross Chain Tokens need to be ERC20-compatible to ensure interoperability across different blockchain ecosystems. The specific requirements for ERC20-compatible tokens in CCIP will be detailed [later](#requirements-for-erc20-compatible-tokens) in this document, including requirements for Burn & Mint and Lock & Mint mechanisms.

- **Token Pool**: Each token is associated with its own token pool, which acts as abstraction layer over ERC-20 tokens designed to facilitate token-related operations for OnRamping and OffRamping. Token pools provide [rate limits](/ccip/architecture#token-pool-rate-limit), a security feature enabling token issuers to set a maximum rate at which their token can be transferred per lane. Token pools are configured to `lock` or `burn` tokens on the source blockchain and `unlock` or `mint` tokens on the destination blockchain. This setup results in four primary mechanisms:

  - **Burn and Mint**: Tokens are burned on the source blockchain, and an equivalent amount of tokens are minted on the destination blockchain. This keeps the total supply of the token constant across blockchains.

        <ClickToZoom
            src="/images/ccip/cct/handling/burn-mint.jpeg"
            alt="Burn and Mint"
        />

  - **Lock and Mint**: This mechanism is suitable for projects with existing tokens on a single blockchain that have already been minted and lack functionality to control the supply via `burn` and `mint` functions on the source blockchain. In this approach, tokens are locked on the issuing blockchain, and fully collateralized "wrapped" tokens are minted on the destination blockchain. These wrapped tokens, which must support `burn` and `mint` functionality, can subsequently be transferred across other non-issuing blockchains using the Burn and Mint mechanism.

          <ClickToZoom
            src="/images/ccip/cct/handling/lock-mint.jpeg"
            alt="Lock and Mint"
        />

  - **Burn and Unlock**: Tokens are burned on the source blockchain (which is the non-issuing blockchain), and an equivalent amount of tokens are released on the destination blockchain (the issuing blockchain). This mechanism is the inverse of the Lock and Mint mechanism and applies when you send tokens back to their issuing source blockchain.

          <ClickToZoom
            src="/images/ccip/cct/handling/burn-unlock.jpeg"
            alt="Burn and Unlock"
        />

  - **Lock and Unlock**: Tokens are locked on the source blockchain, and an equivalent amount of tokens are released on the destination blockchain. This use case should be rare and is generally **discouraged**, as it implies multiple issuing blockchains, which results in fragmented liquidity.

            <ClickToZoom
            src="/images/ccip/cct/handling/lock-unlock.jpeg"
            alt="Lock and Unlock"
        />

## Requirements for ERC20-Compatible Tokens

Before enabling an ERC20-compatible token in CCIP, it's important to understand the requirements it must fulfill to integrate with CCIP.

- **Token Administrator address requirement**: The token contract must provide an easy way to obtain the token administrator address. This can be achieved if the token contract includes one of the following functions:

  - `owner()`: This function returns the token contract owner's address.
  - `getCCIPAdmin()`: This function returns the token administrator's address if it differs from the contract owner's.

- **Requirements for CCIP token transfers**: The token's smart contract must meet minimum requirements to integrate with CCIP.

  - **Burn & Mint Requirements**:
    - The token smart contract must have the following functions:
      - `mint(address account, uint256 amount)`: This function is used to mint the `amount` of tokens to a given `account` on the destination blockchain.
      - `burn(uint256 amount)`: This function is used to burn the `amount` of tokens on the source blockchain.
      - `decimals()`: Returns the token's number of decimals.
    - On the source and destination blockchains, the token contract must support granting mint and burn permissions. The token issuers or another role (such as the token administrator) will grant these permissions to the token pool.
  - **Lock & Mint Requirements**:
    - The token smart contract must have the following function:
      - `decimals()`: Returns the token's number of decimals.
    - On the destination blockchain, The token contract must support granting mint and burn permissions. The token issuers or another role (such as the token administrator) will grant these permissions to the token pool.

If you don't have an existing token: For all blockchains where tokens need to be burned and minted (for example, the source or destination chain in the case of Burn and Mint, or the destination blockchain in the case of Lock and Mint), Chainlink provides a [BurnMintERC677](https://github.com/smartcontractkit/ccip/blob/ccip-develop/contracts/src/v0.8/shared/token/ERC677/BurnMintERC677.sol) contract that you can use to deploy your token in minutes. This token follows the [ERC677](https://github.com/ethereum/EIPs/issues/677) or [ERC777](https://ethereum.org/en/developers/docs/standards/tokens/erc-777/), allowing you to use it as-is or extend it to meet your specific requirements.

## Requirement for Token Pools

### Standard Token Pools

Depending on your use case (token handling mechanism), you need to deploy the appropriate token pool type for each blockchain you want to support.

When CCIP interacts with your token pools, it expects the presence of the following functions:

- **Source Blockchain**: This must include the following function:

  - `lockOrBurn(Pool.LockOrBurnInV1 calldata lockOrBurnIn) external returns (Pool.LockOrBurnOutV1 memory)`: This function locks or burns tokens on the source blockchain. Refer to the [`Pool`](/ccip/api-reference/pool) library API reference for details about the input and output parameters.

- **Destination Blockchain**: This must include the following function:
  - `releaseOrMint(Pool.ReleaseOrMintInV1 calldata releaseOrMintIn) external returns (Pool.ReleaseOrMintOutV1 memory)`: This function releases or mints tokens on the destination blockchain. Refer to the [`Pool`](/ccip/api-reference/pool) library API reference for details about the input and output parameters.

Chainlink provides a set of token pool contracts that you can use to deploy your token pools in minutes. These token pools are fully audited and ready for deployment on your blockchains. You can find the token pool contracts in the [Chainlink GitHub repository](https://github.com/smartcontractkit/ccip/tree/ccip-develop/contracts/src/v0.8/ccip/pools). For most use cases, you can use:

- [BurnMintTokenPool](https://github.com/smartcontractkit/ccip/blob/ccip-develop/contracts/src/v0.8/ccip/pools/BurnMintTokenPool.sol): This token pool is used to burn or mint tokens. You can read the API reference [here](/ccip/api-reference/burn-mint-token-pool).
- [LockReleaseTokenPool](https://github.com/smartcontractkit/ccip/blob/ccip-develop/contracts/src/v0.8/ccip/pools/LockReleaseTokenPool.sol): This token pool is used to lock or release tokens. You can read the API reference [here](/ccip/api-reference/lock-release-token-pool).

**Note**: Both token pools inherit from the same base [TokenPool](https://github.com/smartcontractkit/ccip/blob/ccip-develop/contracts/src/v0.8/ccip/pools/TokenPool.sol) contract, which provides all the common functions necessary for a token pool. For example, it includes the [`applyChainUpdates`](/ccip/api-reference/token-pool#applychainupdates) function, which is used to configure the token pool. You can read the API reference [here](/ccip/api-reference/token-pool).

### Token Handling Mechanisms and Token Pool Deployment

To facilitate cross-chain token transfers, you need to choose the appropriate token handling mechanism and deploy the correct combination of token pools for the source and destination blockchains. The table below summarizes the different token handling mechanisms and the recommended token pools to deploy for each scenario, ensuring a seamless token transfer process.

| Token Handling Mechanism | Source Blockchain Token Pool | Destination Blockchain Token Pool | Notes                                                                                                                                                                                                           |
| ------------------------ | ---------------------------- | --------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Burn and Mint            | BurnMintTokenPool            | BurnMintTokenPool                 | - Standard burn and mint mechanism for cross-chain token transfers.                                                                                                                                             |
| Lock and Mint            | LockReleaseTokenPool         | BurnMintTokenPool                 | - The source blockchain is the issuing blockchain. <br/> - LockReleaseTokenPool **must** be deployed on the issuing blockchain.                                                                                 |
| Burn and Unlock          | BurnMintTokenPool            | LockReleaseTokenPool              | - The destination blockchain is the issuing blockchain. <br/> - BurnMintTokenPool is used to burn tokens on the source blockchain, and LockReleaseTokenPool is used to unlock tokens on the issuing blockchain. |

### Custom Token Pools

If the standard token pools do not meet your requirements, you have the option to build a custom TokenPool. However, it is essential to adhere to the following guidelines:

- Your custom TokenPool must inherit from the base token pool contract and implement the mandatory functions for both the source and destination blockchains. (Refer to the [Standard Token Pools](#standard-token-pools) section for more details.)

- A critical aspect to consider for custom token pools is the **reception logic** on the destination blockchain. Specifically, the `releaseOrMint` function should not consume more than **90,000 gas**. If this limit is exceeded, the CCIP execution on the destination blockchain will fail, requiring manual intervention by the user to execute the transaction. For more information, see [Manual execution](/ccip/concepts/manual-execution).

- If your token pool requires more than **90,000** gas on the destination blockchain, you should contact Chainlink Labs to update an internal CCIP parameter to avoid execution failure. It is highly recommended to design your custom TokenPool to stay within the 90,000 gas limit whenever possible.

Here are some examples of use cases that may require custom token pools:

- **Tokens with different decimals across blockchains**:

  - **Use Case**: Some tokens have different decimal values across various blockchains.
  - **Solution**:

    - **Source Blockchain**: During the lock or burn process on the source blockchain, the TokenPool should include a shared denomination in the `destPoolData` field of the [`LockOrBurnOutV1`](/ccip/api-reference/pool#lockorburnoutv1) struct (returned by the `lockOrBurn` function) to represent the value in a standard format. This data is then passed to the destination blockchain via CCIP.
    - **Destination Blockchain**: On the destination blockchain, the TokenPool should use the information contained in the `sourcePoolData` of the [`ReleaseOrMintInV1`](/ccip/api-reference/pool#releaseormintinv1) struct (used by the `releaseOrMint` function) to convert the value into the local denomination. The correct number of tokens should then be minted based on the destination blockchain's decimal format. The minted amount is returned in the `destinationAmount` field of the [`ReleaseOrMintOutV1`](/ccip/api-reference/pool#releaseormintoutv1) struct, which is returned by the `releaseOrMint` function.

- **Tokens with rebasing**:

  - **Use Case**: Rebasing tokens are a unique type of token that adjusts its supply in response to specific parameters (e.g., price). These tokens require custom logic to handle rebasing events during cross-chain transfers.
  - **Solution**:
    - **Source Blockchain**: When initiating a cross-chain transfer of rebasing tokens, the TokenPool on the source blockchain should lock or burn the underlying shares rather than a fixed amount of tokens. This ensures that the value is consistently represented, regardless of changes in supply. The number of shares being locked or burned is recorded in the [`destPoolData`](/ccip/api-reference/pool#lockorburnoutv1) and passed to the destination blockchain.
    - **Destination Blockchain**: On the destination blockchain, the TokenPool should accurately convert the number of underlying shares to tokens using the current share-to-token ratio. The calculated token amount should then be minted on the destination blockchain and returned in the `destinationAmount` field of the [`ReleaseOrMintOutV1`](/ccip/api-reference/pool#releaseormintoutv1) struct, which is returned by the `releaseOrMint` function.

## CCT Architecture Overview
