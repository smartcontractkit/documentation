---
section: ccip
date: Last Modified
title: "Get Started (EVM)"
metadata:
  description: "Get started with Chainlink CCIP on EVM chains. Deploy sender/receiver contracts, send data cross-chain, and pay fees in LINK."
  excerpt: "Chainlink CCIP, EVM chains, Ethereum, Avalanche, Cross-chain messaging, Solidity contracts, LINK token, Remix IDE, MetaMask, Testnet"
  datePublished: "2025-05-19"
  lastModified: "2025-05-19"
  estimatedTime: "20 minutes"
whatsnext:
  {
    "Learn how to transfer tokens": "/ccip/tutorials/evm/transfer-tokens-from-contract",
    "Learn how to transfer tokens and send data in a single CCIP transaction": "/ccip/tutorials/evm/programmable-token-transfers",
    "Transfer Tokens Between EOAs": "/ccip/tutorials/evm/offchain/transfer-tokens-from-eoa",
    "Learn how to send arbitrary data over CCIP": "/ccip/tutorials/evm/send-arbitrary-data",
    "CCIP Directory": "/ccip/directory",
  }
---

import { Accordion, CodeSample, ClickToZoom, CopyText, Aside } from "@components"
import CcipCommon from "@features/ccip/CcipCommon.astro"

**Build and run a secure cross-chain messaging workflow between two EVM chains using Chainlink CCIP.**

By the end of this guide, you will:

- Deploy a sender on a source chain
- Deploy a receiver on a destination chain
- Send and verify a cross-chain message

## Before you begin

You will need:

- Basic [Solidity](https://soliditylang.org/) and [smart contract deployment](/quickstarts/deploy-your-first-contract) experience
- One [wallet](https://metamask.io/) funded on two CCIP-supported EVM testnets

- Choose one of the following development environments:
  - **[Hardhat](https://hardhat.org/docs/getting-started) (recommended)**
    Best for a **script-driven workflow** where you deploy contracts, send a CCIP message, and verify delivery from the command line. Ideal for getting a full end-to-end CCIP flow running quickly.

  - **[Foundry](https://book.getfoundry.sh/)**
    Best for **Solidity-native, test-driven workflows**, where CCIP messaging is validated through tests and assertions rather than scripts.

  - **[Remix](https://remix.ethereum.org/)**
    Suitable only for **quick, disposable demos**. Not recommended for testing, iteration, or production workflows.

## Build and send a message

### Hardhat

In this section, you will use preconfigured Hardhat scripts to deploy both contracts, send a CCIP message, and verify cross-chain delivery from the command line.

<br />

<Accordion title="Bootstrap the Hardhat project" number={1}>
1. Open a new terminal in a directory of your choice and run:

```bash
npx hardhat --init
```

2. Create a project with the following options:

- **Hardhat Version:** `hardhat-3`
- **Initialize project:** At root of the project
- **Type of project:** A minimal Hardhat project
- **Install the necessary dependencies:** Yes

3. Install the additional dependencies required by this tutorial:

```bash
npm install @chainlink/contracts-ccip @chainlink/contracts @openzeppelin/contracts viem dotenv
npm install --save-dev @nomicfoundation/hardhat-viem
```

<Aside type="danger" title="Don't use mainnet private keys">
  Private keys stored in `.env` files have been compromised and accidentally pushed online before. Use a fresh test-only
  key with no mainnet funds.
</Aside>

4. Create a `.env` file with the following variables:

```bash
PRIVATE_KEY=0x.....
SEPOLIA_RPC_URL=https.....
FUJI_RPC_URL=https.....
```

5. Update `hardhat.config.ts` to use your environment variables and the `hardhat-viem` plugin:

```ts
import "dotenv/config"
import { configVariable, defineConfig } from "hardhat/config"
import hardhatViem from "@nomicfoundation/hardhat-viem"

export default defineConfig({
  plugins: [hardhatViem],
  solidity: {
    version: "0.8.24",
  },
  networks: {
    sepolia: {
      type: "http",
      url: configVariable("SEPOLIA_RPC_URL"),
      accounts: [configVariable("PRIVATE_KEY")],
    },
    avalancheFuji: {
      type: "http",
      url: configVariable("FUJI_RPC_URL"),
      accounts: [configVariable("PRIVATE_KEY")],
    },
  },
})
```

</Accordion>

<Accordion title="Add the CCIP contracts" number={2}>
1. Create a new directory named `contracts` for your smart contracts if it doesn't already exist:

```bash
mkdir -p contracts
```

2. Create a new file named `Sender.sol` in this directory and paste the sender contract code inside it.

3. Create a new file named `Receiver.sol` in the same directory and paste the receiver contract code inside it.

4. Create a `contracts/interfaces` directory and create a new file named `IERC20.sol` inside it. Our script will need to make a call to the LINK ERC-20 contract to transfer LINK to the sender contract, so it needs an ERC-20 interface to call `transfer`.

```bash
mkdir -p contracts/interfaces
```

5. Paste the following code into `contracts/interfaces/IERC20.sol`:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

// Re-export OpenZeppelin's IERC20 interface
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface IERC20Extended is IERC20 {}
```

Run the following command to compile the contracts:

```bash
npx hardhat build
```

</Accordion>

<Accordion title="Set up the scripts" number={3}>
1. Create a new directory named `scripts` at the root of the project if it doesn't already exist:

```bash
mkdir -p scripts
```

2. Create a new file named `send-cross-chain-message.ts` in this directory and paste the following code inside it:

```ts
import { network } from "hardhat"
import { parseUnits } from "viem"

// Avalanche Fuji configuration
const FUJI_ROUTER = "0xF694E193200268f9a4868e4Aa017A0118C9a8177"
const FUJI_LINK = "0x0b9d5D9136855f6FEc3c0993feE6E9CE8a297846"

// Ethereum Sepolia configuration
// Note that the contract on Sepolia doesn't need to have LINK to pay for CCIP fees.
const SEPOLIA_ROUTER = "0x0BF3dE8c5D3e8A2B34D2BEeB17ABfCeBaf363A59"
const SEPOLIA_CHAIN_SELECTOR = 16015286601757825753n

// Connect to Avalanche Fuji
console.log("Connecting to Avalanche Fuji...")
const fujiNetwork = await network.connect("avalancheFuji")

// Connect to Ethereum Sepolia
console.log("Connecting to Ethereum Sepolia...")
const sepoliaNetwork = await network.connect("sepolia")

// Step 1: Deploy Sender on Fuji
console.log("\n[Step 1] Deploying Sender contract on Avalanche Fuji...")

const sender = await fujiNetwork.viem.deployContract("Sender", [FUJI_ROUTER, FUJI_LINK])
const fujiPublicClient = await fujiNetwork.viem.getPublicClient()

console.log(`Sender contract has been deployed to this address on the Fuji testnet: ${sender.address}`)
console.log(`View on Avascan: https://testnet.avascan.info/blockchain/all/address/${sender.address}`)

// Step 2: Fund Sender with LINK
console.log("\n[Step 2] Funding Sender with 1 LINK...")

const fujiLinkToken = await fujiNetwork.viem.getContractAt("IERC20Extended", FUJI_LINK)

const transferLinkToFujiContract = await fujiLinkToken.write.transfer([sender.address, parseUnits("1", 18)])

console.log("LINK token transfer in progress, awaiting confirmation...")
await fujiPublicClient.waitForTransactionReceipt({ hash: transferLinkToFujiContract, confirmations: 1 })
console.log(`Funded Sender with 1 LINK`)

// Step 3: Deploy Receiver on Sepolia
console.log("\n[Step 3] Deploying Receiver on Ethereum Sepolia...")

const receiver = await sepoliaNetwork.viem.deployContract("Receiver", [SEPOLIA_ROUTER])
const sepoliaPublicClient = await sepoliaNetwork.viem.getPublicClient()

console.log(`Receiver contract has been deployed to this address on the Sepolia testnet: ${receiver.address}`)
console.log(`View on Etherscan: https://sepolia.etherscan.io/address/${receiver.address}`)
console.log(`\nðŸ“‹ Copy the receiver address since it will be needed to run the verification script ðŸ“‹ \n`)

// Step 4: Send cross-chain message
console.log("\n[Step 4] Sending cross-chain message...")

const sendMessageTx = await sender.write.sendMessage([
  SEPOLIA_CHAIN_SELECTOR,
  receiver.address,
  "Hello World! cdnjkdjmdsd",
])

console.log("Cross-chain message sent, awaiting confirmation...")
console.log(`Message sent from source contract! âœ… \n Tx hash: ${sendMessageTx}`)
console.log(`View transaction status on CCIP Explorer: https://ccip.chain.link`)
console.log(
  "Run the receiver script after 10 minutes to check if the message has been received on the destination contract."
)
```

3. Wait for a few minutes for the message to be delivered to the receiver contract. Then create a new file named `verify-cross-chain-message.ts` in the `scripts` directory and paste the following code inside it:

<Aside type="note" title="Paste the Receiver contract address here">
  The verification script calls `getLastReceivedMessageDetails` on the receiver contract. It needs the correct receiver
  address to read from.
</Aside>

```ts
import { network } from "hardhat"

// Paste the Receiver contract address
const RECEIVER_ADDRESS = ""

console.log("Connecting to Ethereum Sepolia...")
const sepoliaNetwork = await network.connect("sepolia")

console.log("Checking for received message...\n")
const receiver = await sepoliaNetwork.viem.getContractAt("Receiver", RECEIVER_ADDRESS)

const [messageId, text] = await receiver.read.getLastReceivedMessageDetails()

// A null hexadecimal value means no message has been received yet
const ZERO_BYTES32 = "0x0000000000000000000000000000000000000000000000000000000000000000"

if (messageId === ZERO_BYTES32) {
  console.log("No message received yet.")
  console.log("Please wait a bit longer and try again.")
  process.exit(1)
} else {
  console.log(`âœ… Message ID: ${messageId}`)
  console.log(`Text: "${text}"`)
}
```

</Accordion>

<Accordion title="Deploy the contracts" number={4}>

<Aside type="note" title="Fund your wallet before deploying">
Before running the deployment script, make sure of the following:

- You use the **same wallet address** on both networks.
- Your wallet has **testnet ETH on both networks** used in this guide:
  - **Avalanche Fuji** (source chain)
  - **Ethereum Sepolia** (destination chain)
    <br />
    Testnet ETH is required to:
  - Deploy the sender and receiver contracts
  - Pay transaction fees during deployment and message sending
  - If your wallet is not funded on both chains, the script will fail.
</Aside>

1. Run the following command to deploy the contracts:

```bash
npx hardhat run scripts/send-cross-chain-message.ts
```

The script logs the deployed contract addresses to the terminal.

</Accordion>

<Accordion title="Send a CCIP message" number={5}>
1. Run the following command to send the cross-chain message:

```bash
npx hardhat run scripts/send-cross-chain-message.ts
```

2. Wait a few minutes for the message to be delivered to the receiver contract.
   </Accordion>

<Accordion title="Verify cross-chain delivery" number={6}>
1. Paste the Receiver contract address into `RECEIVER_ADDRESS` in `scripts/verify-cross-chain-message.ts`, then run:

```bash
npx hardhat run scripts/verify-cross-chain-message.ts
```

You should see the message ID and text of the last received message printed in the terminal.

</Accordion>

### Foundry

Use this path if you prefer Solidity-native workflows and want to verify CCIP messaging using tests and assertions.

....

### Remix

Use this path only for quick experimentation. This path is **not suitable for testing or production use**. For real applications, migrate to Hardhat or Foundry.

....

## Common issues and debugging

If your message does not execute as expected, check the following:

- **Incorrect router address or chain selector**
- **Insufficient fee payment on the source chain**
- **Receiver execution revert**
- **Message still in transit** (cross-chain delivery is not instant)

Most issues are configuration-related and can be resolved by verifying network-specific values.

## Next steps

After completing this guide, you can:

- Send tokens cross-chain with CCIP
- Add automated tests to your project
- Monitor message status programmatically
- Deploy CCIP applications to mainnet
