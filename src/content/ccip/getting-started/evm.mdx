---
section: ccip
date: Last Modified
title: "Get Started with CCIP (EVM)"
metadata:
  description: "Get started with Chainlink CCIP on EVM chains. Deploy sender/receiver contracts, send data cross-chain, and pay fees in LINK."
  excerpt: "Chainlink CCIP, EVM chains, Ethereum, Avalanche, Cross-chain messaging, Solidity contracts, LINK token, Remix IDE, MetaMask, Testnet"
  datePublished: "2025-05-19"
  lastModified: "2025-12-25"
  estimatedTime: "20 minutes"
whatsnext:
  {
    "Learn how to transfer tokens": "/ccip/tutorials/evm/transfer-tokens-from-contract",
    "Learn how to transfer tokens and send data in a single CCIP transaction": "/ccip/tutorials/evm/programmable-token-transfers",
    "Transfer Tokens Between EOAs": "/ccip/tutorials/evm/offchain/transfer-tokens-from-eoa",
    "Learn how to send arbitrary data over CCIP": "/ccip/tutorials/evm/send-arbitrary-data",
    "CCIP Directory": "/ccip/directory",
  }
---

import { Callout } from "@components/Callout/Callout.tsx"
import { Accordion, CodeSample, ClickToZoom, CopyText, Aside } from "@components"
import CcipCommon from "@features/ccip/CcipCommon.astro"

<CcipCommon callout="talkToExpert" />

**Build and run a secure cross-chain messaging workflow between two EVM chains using Chainlink CCIP.**

In this guide, you will:

1. Deploy a sender on a source chain
2. Deploy a receiver on a destination chain
3. Send and verify a cross-chain message

## Before you begin

You will need:

- Basic [Solidity](https://soliditylang.org/) and [smart contract deployment](/quickstarts/deploy-your-first-contract) experience
- One [wallet](https://metamask.io/) funded on two CCIP-supported EVM testnets

- Choose one of the following development environments:
  - **[Hardhat](https://hardhat.org/docs/getting-started) (recommended)**
    Best for a **script-driven workflow** where you deploy contracts, send a CCIP message, and verify delivery from the command line. Ideal for getting a full end-to-end CCIP flow running quickly.

  - **[Foundry](https://book.getfoundry.sh/)**
    Best for **Solidity-native, test-driven workflows**, where CCIP messaging is validated through tests and assertions rather than scripts.

  - **[Remix](https://remix.ethereum.org/)**
    Suitable only for **quick, disposable demos**. Not recommended for testing, iteration, or production workflows.

## Examine the example code

<Accordion title="Sender code" number={1}>

The smart contract in this tutorial is designed to interact with CCIP to send data. The contract code includes comments to clarify the various functions, events, and underlying logic. However, this section explains the key elements. You can see the full contract code below.

<CodeSample src="samples/CCIP/Sender.sol" />

#### Initializing the contract

When deploying the contract, you define the router address and the LINK contract address of the blockchain where you choose to deploy the contract.

The router address provides functions that are required for this example:

- The `getFee` [function](/ccip/api-reference/evm/v1.6.1/i-router-client#getfee) to estimate the CCIP fees.
- The `ccipSend` [function](/ccip/api-reference/evm/v1.6.1/i-router-client#ccipsend) to send CCIP messages.

#### Sending data

The `sendMessage` function completes several operations:

1. Construct a CCIP-compatible message using the `EVM2AnyMessage` [struct](/ccip/api-reference/evm/v1.6.1/client#evm2anymessage):
   - The `receiver` address is encoded in bytes format to accommodate non-EVM destination blockchains with distinct address formats. The encoding is achieved through [abi.encode](https://docs.soliditylang.org/en/develop/abi-spec.html).
   - The `data` is encoded from a string text to bytes using [abi.encode](https://docs.soliditylang.org/en/develop/abi-spec.html).
   - The `tokenAmounts` is an array. Each element comprises a [struct](/ccip/api-reference/evm/v1.6.1/client#evmtokenamount) that contains the token address and amount. In this example, the array is empty because no tokens are sent.
   - The `extraArgs` specify the `gasLimit` for relaying the CCIP message to the recipient contract on the destination blockchain. In this example, the `gasLimit` is set to `200000`.
   - The `feeToken` designates the token address used for CCIP fees. Here, `address(linkToken)` signifies payment in LINK.

1. Compute the fees by invoking the router's `getFee` [function](/ccip/api-reference/evm/v1.6.1/i-router-client#getfee).
1. Ensure that your contract balance in LINK is enough to cover the fees.
1. Grant the router contract permission to deduct the fees from the contract's LINK balance.
1. Dispatch the CCIP message to the destination chain by executing the router's `ccipSend` [function](/ccip/api-reference/evm/v1.6.1/i-router-client#ccipsend).

<CcipCommon callout="senderContractCallout" />

</Accordion>

<Accordion title="Receiver code" number={2}>

The smart contract in this tutorial is designed to interact with CCIP to receive data. The contract code includes comments to clarify the various functions, events, and underlying logic. However, this section explains the key elements. You can see the full contract code below.

<CodeSample src="samples/CCIP/Receiver.sol" />

#### Initializing the contract

When you deploy the contract, you define the router address. The receiver contract inherits from the [CCIPReceiver.sol](/ccip/api-reference/evm/v1.6.1/ccip-receiver) contract, which uses the router address.

#### Receiving data

On the destination blockchain:

1. The CCIP Router invokes the `ccipReceive` [function](/ccip/api-reference/evm/v1.6.1/ccip-receiver#ccipreceive). **Note**: This function is protected by the `onlyRouter` [modifier](/ccip/api-reference/evm/v1.6.1/ccip-receiver#onlyrouter), which ensures that only the router can call the receiver contract.
1. The `ccipReceive` [function](/ccip/api-reference/evm/v1.6.1/ccip-receiver#ccipreceive) calls an internal function `_ccipReceive` [function](/ccip/api-reference/evm/v1.6.1/ccip-receiver#_ccipreceive). The receiver contract implements this function.
1. This `_ccipReceive` [function](/ccip/api-reference/evm/v1.6.1/ccip-receiver#_ccipreceive) expects an `Any2EVMMessage` [struct](/ccip/api-reference/evm/v1.6.1/client#any2evmmessage) that contains the following values:
   - The CCIP `messageId`.
   - The `sourceChainSelector`.
   - The `sender` address in bytes format. The sender is a contract deployed on an EVM-compatible blockchain, so the address is decoded from bytes to an Ethereum address using the [ABI specification](https://docs.soliditylang.org/en/v0.8.20/abi-spec.html).
   - The `data` is also in bytes format. A `string` is expected, so the data is decoded from bytes to a string using the [ABI specification](https://docs.soliditylang.org/en/v0.8.20/abi-spec.html).

<Aside type="caution" title="Recommendations Receiver contract">
The example was simplified for learning purposes. For production code, use the following best practices:

    - Validate the source chain.
    - Depending on your use case, analyze whether you should validate the sender address.

Note that the receiver contract in this example inherits from the base contract [CCIPReceiver.sol](/ccip/api-reference/evm/v1.6.1/ccip-receiver), which uses the `onlyRouter` [modifier](/ccip/api-reference/evm/v1.6.1/ccip-receiver#onlyrouter) to ensure that only the router can call the `ccipReceive` [function](/ccip/api-reference/evm/v1.6.1/ccip-receiver#ccipreceive).

</Aside>

</Accordion>

## Send a cross-chain message using CCIP

### Hardhat

<Accordion title="Bootstrap a new Hardhat project" number={1}>

1. Open a new terminal in a directory of your choice and run this command:

```bash filename="terminal"
npx hardhat --init
```

Create a project with the following options:

- Hardhat Version: hardhat-3
- Initialize project: At root of the project
- Type of project: A minimal Hardhat project
- Install the necessary dependencies: Yes

2. Install the additional dependencies required by this tutorial:

```bash filename="terminal"
npm install @chainlink/contracts-ccip @chainlink/contracts @openzeppelin/contracts viem dotenv
npm install --save-dev @nomicfoundation/hardhat-viem
```

<Callout type="danger" title="PLEASE DON'T USE PRIVATE KEYS WITH MAINNET FUNDS">
  Private keys stored in `.env` files have been compromised and accidently pushed online before. Please be VERY CAREFUL
  while choosing which private key to use for this tutorial.
</Callout>

3. Create a `.env` file with the following variables:

```env filename=".env"
PRIVATE_KEY=0x.....
SEPOLIA_RPC_URL=https.....
FUJI_RPC_URL=https.....
```

4. Update `hardhat.config.ts` to use your environment variables and the `hardhat-viem` plugin:

```typescript filename="hardhat.config.ts"
import "dotenv/config"
import { configVariable, defineConfig } from "hardhat/config"
import hardhatViem from "@nomicfoundation/hardhat-viem"

export default defineConfig({
  plugins: [hardhatViem],
  solidity: {
    version: "0.8.24",
  },
  networks: {
    sepolia: {
      type: "http",
      url: configVariable("SEPOLIA_RPC_URL"),
      accounts: [configVariable("PRIVATE_KEY")],
    },
    avalancheFuji: {
      type: "http",
      url: configVariable("FUJI_RPC_URL"),
      accounts: [configVariable("PRIVATE_KEY")],
    },
  },
})
```

</Accordion>

<Accordion title="Set up the contracts" number={2}>

1. Create a new directory named `contracts` for your smart contracts if it doesn't already exist.
2. Create a new file named `Sender.sol` in this directory and paste the sender contract code inside it.
3. Create a new file named `Receiver.sol` in the same directory and paste the receiver contract code inside it.
4. Create a `contracts/interfaces` directory and create a new file named `IERC20.sol` inside it. Our script will need to make a call to the `LINK ERC-20` contract to transfer LINK to the sender contract.
   It will need access to an ERC-20 interface to be able to call the `transfer` function.
5. Paste the following code into the `IERC20.sol` file:

```solidity filename="contracts/interfaces/IERC20.sol"
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

// Re-export OpenZeppelin's IERC20 interface
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface IERC20Extended is IERC20 {}
```

6. Run the following command to compile the contracts:

```bash filename="terminal"
npx hardhat build
```

</Accordion>

<Accordion title="Send a cross-chain message using CCIP" number={3}>

1. Create a new directory named `scripts` at the root of the project if it doesn't already exist.
2. Create a new file named `send-cross-chain-message.ts` in this directory and paste the following code inside it:

```typescript filename="scripts/send-cross-chain-message.ts"
import { network } from "hardhat"
import { parseUnits } from "viem"

// Avalanche Fuji configuration
const FUJI_ROUTER = "0xF694E193200268f9a4868e4Aa017A0118C9a8177"
const FUJI_LINK = "0x0b9d5D9136855f6FEc3c0993feE6E9CE8a297846"

// Ethereum Sepolia configuration
// Note that the contract on Sepolia doesn't need to have LINK to pay for CCIP fees.
const SEPOLIA_ROUTER = "0x0BF3dE8c5D3e8A2B34D2BEeB17ABfCeBaf363A59"
const SEPOLIA_CHAIN_SELECTOR = 16015286601757825753n

// Connect to Avalanche Fuji
console.log("Connecting to Avalanche Fuji...")
const fujiNetwork = await network.connect("avalancheFuji")

// Connect to Ethereum Sepolia
console.log("Connecting to Ethereum Sepolia...")
const sepoliaNetwork = await network.connect("sepolia")

// Step 1: Deploy Sender on Fuji
console.log("\n[Step 1] Deploying Sender contract on Avalanche Fuji...")

const sender = await fujiNetwork.viem.deployContract("Sender", [FUJI_ROUTER, FUJI_LINK])
const fujiPublicClient = await fujiNetwork.viem.getPublicClient()

console.log(`Sender contract has been deployed to this address on the Fuji testnet: ${sender.address}`)
console.log(`View on Avascan: https://testnet.avascan.info/blockchain/all/address/${sender.address}`)

// Step 2: Fund Sender with LINK
console.log("\n[Step 2] Funding Sender with 1 LINK...")

const fujiLinkToken = await fujiNetwork.viem.getContractAt("IERC20Extended", FUJI_LINK)

const transferLinkToFujiContract = await fujiLinkToken.write.transfer([sender.address, parseUnits("1", 18)])

console.log("LINK token transfer in progress, awaiting confirmation...")
await fujiPublicClient.waitForTransactionReceipt({ hash: transferLinkToFujiContract, confirmations: 1 })
console.log(`Funded Sender with 1 LINK`)

// Step 3: Deploy Receiver on Sepolia
console.log("\n[Step 3] Deploying Receiver on Ethereum Sepolia...")

const receiver = await sepoliaNetwork.viem.deployContract("Receiver", [SEPOLIA_ROUTER])
const sepoliaPublicClient = await sepoliaNetwork.viem.getPublicClient()

console.log(`Receiver contract has been deployed to this address on the Sepolia testnet: ${receiver.address}`)
console.log(`View on Etherscan: https://sepolia.etherscan.io/address/${receiver.address}`)
console.log(`\nðŸ“‹ Copy the receiver address since it will be needed to run the verification script ðŸ“‹ \n`)

// Step 4: Send cross-chain message
console.log("\n[Step 4] Sending cross-chain message...")

const sendMessageTx = await sender.write.sendMessage([
  SEPOLIA_CHAIN_SELECTOR,
  receiver.address,
  "Hello World! cdnjkdjmdsd",
])

console.log("Cross-chain message sent, awaiting confirmation...")
console.log(`Message sent from source contract! âœ… \n Tx hash: ${sendMessageTx}`)
console.log(`View transaction status on CCIP Explorer: https://ccip.chain.link`)
console.log(
  "Run the receiver script after 10 minutes to check if the message has been received on the destination contract."
)
```

This script does the following:

- Connects to the Avalanche Fuji and Ethereum Sepolia networks.
- Deploys the sender contract on Avalanche Fuji.
- Funds the sender contract with 1 LINK.
- Deploys the receiver contract on Ethereum Sepolia.
- Sends a cross-chain message from the sender contract to the receiver contract.

3. Run the following command to send the cross-chain message:

```bash filename="terminal"
npx hardhat run scripts/send-cross-chain-message.ts
```

4. Wait for a few minutes for the message to be delivered to the receiver contract.
   Then create a new file named `verify-cross-chain-message.ts` in the `scripts` directory and paste the following code inside it:

<Callout type="note" title="Paste the Receiver contract address here">
  The second script will call the `getLastReceivedMessageDetails` function on the receiver contract to verify if the
  message has been received. It will need the correct address to call the function.
</Callout>

```typescript filename="scripts/verify-cross-chain-message.ts"
import { network } from "hardhat"

// Paste the Receiver contract address
const RECEIVER_ADDRESS = ""

console.log("Connecting to Ethereum Sepolia...")
const sepoliaNetwork = await network.connect("sepolia")

console.log("Checking for received message...\n")
const receiver = await sepoliaNetwork.viem.getContractAt("Receiver", RECEIVER_ADDRESS)

const [messageId, text] = await receiver.read.getLastReceivedMessageDetails()

// A null hexadecimal value means no message has been received yet
const ZERO_BYTES32 = "0x0000000000000000000000000000000000000000000000000000000000000000"

if (messageId === ZERO_BYTES32) {
  console.log("No message received yet.")
  console.log("Please wait a bit longer and try again.")
  process.exit(1)
} else {
  console.log(`âœ… Message ID: ${messageId}`)
  console.log(`Text: "${text}"`)
}
```

This script does the following:

- Connects to the Ethereum Sepolia network.
- Reads the last received message details from the receiver contract.
- Checks if any message has been received.
- Prints the message ID and text of the last received message.

5. Run the following command to verify the cross-chain message:

```bash filename="terminal"
npx hardhat run scripts/verify-cross-chain-message.ts
```

6. You should see the message ID and text of the last received message printed in the terminal.

</Accordion>

### Foundry

<Accordion title="Bootstrap a new Foundry project" number={1}>

1. Open a new terminal in a directory of your choice and run this command to initialize a new Foundry project at the root:

```bash filename="terminal"
forge init
```

2. Install the required dependencies:

```bash filename="terminal"
forge install smartcontractkit/chainlink-ccip smartcontractkit/chainlink-evm OpenZeppelin/openzeppelin-contracts
```

3. Configure the remappings so that your `foundry.toml` file looks like this:

```toml filename="foundry.toml"
[profile.default]
solc = "0.8.24"
src = "src"
out = "out"
libs = ["lib"]

remappings = [
  "forge-std/=lib/forge-std/src/",
  "@chainlink/contracts-ccip/contracts/=lib/chainlink-ccip/chains/evm/contracts/",
  "@chainlink/contracts/=lib/chainlink-evm/contracts/",
  "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/",
  "@openzeppelin/contracts@5.0.2/=lib/openzeppelin-contracts/contracts/",
]

# RPC URLs will be fed to our script via Foundry's config file
[rpc_endpoints]
sepolia = "${SEPOLIA_RPC_URL}"
fuji = "${FUJI_RPC_URL}"
```

4. Create a `.env` at the root of the project with the following variables:

```env filename=".env"
PRIVATE_KEY=0x...
SEPOLIA_RPC_URL=https://...
FUJI_RPC_URL=https://...
```

<Aside type="note">
  You might need to run `source .env` to load the environment variables into your terminal session to access them in
  your script.
</Aside>

</Accordion>

<Accordion title="Set up the contracts" number={2}>

1. Create a new directory named `src` at the root of the project if it doesn't already exist.
2. Create a new file named `Sender.sol` in this directory and paste the sender contract code inside it.
3. Create a new file named `Receiver.sol` in the same directory and paste the receiver contract code inside it.
4. Create a `src/interfaces` directory and create a new file named `IERC20.sol` inside it. Our script will need to make a call to the `LINK ERC-20` contract to transfer LINK to the sender contract.
   It will need access to an ERC-20 interface to be able to call the `transfer` function.
5. Paste the following code into the `IERC20.sol` file:

```solidity filename="contracts/interfaces/IERC20.sol"
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

// Re-export OpenZeppelin's IERC20 interface
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface IERC20Extended is IERC20 {}
```

6. Run the following command to compile the contracts:

```bash filename="terminal"
forge build
```

</Accordion>

<Accordion title="Send a cross-chain message using CCIP" number={3}>

1. Create a new directory named `script` at the root of the project if it doesn't already exist.
2. Create a new file named `SendCrossChainMessage.s.sol` in this directory and paste the following code inside it:

```solidity filename="script/SendCrossChainMessage.s.sol"
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.24;

import {Script, console} from "forge-std/Script.sol";

import {Sender} from "../src/Sender.sol";
import {Receiver} from "../src/Receiver.sol";
import {IERC20Extended} from "../src/interfaces/IERC20.sol";

contract SendCrossChainMessage is Script {
    // Avalanche Fuji configuration
    address constant FUJI_ROUTER = 0xF694E193200268f9a4868e4Aa017A0118C9a8177;
    address constant FUJI_LINK = 0x0b9d5D9136855f6FEc3c0993feE6E9CE8a297846;

    // Ethereum Sepolia configuration
    address constant SEPOLIA_ROUTER =0x0BF3dE8c5D3e8A2B34D2BEeB17ABfCeBaf363A59;
    uint64 constant SEPOLIA_CHAIN_SELECTOR = 16015286601757825753;

    // Configuring decimal value for LINK token
    uint256 ONE_LINK = 1e18;

    function run() public {
        // Load private key from env file
        uint256 deployerPrivateKey = vm.envUint("PRIVATE_KEY");

        // Load form configs from foundry.toml
        uint256 fujiFork = vm.createFork(vm.rpcUrl("fuji"));
        uint256 sepoliaFork = vm.createFork(vm.rpcUrl("sepolia"));

        // Step 1: Deploy Sender on Fuji

        // Connect to Fuji Network
        console.log("Connecting to Avalanche Fuji...");
        vm.selectFork(fujiFork);
        vm.startBroadcast(deployerPrivateKey);

        // Deploy Sender contract
        console.log("\n[Step 1] Deploying Sender contract on Avalanche Fuji...");
        Sender sender = new Sender(FUJI_ROUTER, FUJI_LINK);
        console.log("Sender contract has been deployed to this address on the Fuji testnet:", address(sender));
        console.log(
            string.concat(
                "View on Avascan: https://testnet.avascan.info/blockchain/all/address/",
                vm.toString(address(sender))
            )
        );

        // Step 2: Fund Sender with 1 LINK
        console.log("\n[Step 2] Funding Sender with 1 LINK on Avalanche Fuji...");
        IERC20Extended(FUJI_LINK).transfer(address(sender), ONE_LINK);
        vm.stopBroadcast();
        console.log("Funded Sender with 1 LINK on Fuji");

        // Step 3: Deploy Receiver on Sepolia

        // Connect to Sepolia Network
        console.log("Connecting to Ethereum Sepolia...");
        vm.selectFork(sepoliaFork);
        vm.startBroadcast(deployerPrivateKey);

        // Deploy Receiver contract

        console.log("\n[Step 3] Deploying Receiver contract on Ethereum Sepolia...");
        Receiver receiver = new Receiver(SEPOLIA_ROUTER);
        vm.stopBroadcast();
        console.log("Receiver deployed on Sepolia at this address:", address(receiver));
        console.log(
            string.concat(
                "View on Etherscan: https://sepolia.etherscan.io/address/",
                vm.toString(address(receiver))
            )
        );
        console.log("\n .....Copy the receiver address since it will be needed to run the verification script.....\n");
        console.log(address(receiver));

        // Step 4: Send cross-chain message (Fuji -> Sepolia)
        vm.selectFork(fujiFork);
        vm.startBroadcast(deployerPrivateKey);

        // Send cross-chain message
        console.log("Sending cross-chain message from Fuji to Sepolia...");
        bytes32 messageId = sender.sendMessage(
            SEPOLIA_CHAIN_SELECTOR,
            address(receiver),
            "Hello World from Foundry script!"
        );
        vm.stopBroadcast();

        console.log("The message has been sent to the CCIP router on Fuji, check for successful delivery after 5 minutes...");
        console.log("CCIP messageId:");
        console.logBytes32(messageId);
        console.log("View transaction status on CCIP Explorer: https://ccip.chain.link");
    }
}
```

3. Run the following command to send the cross-chain message:

```bash filename="terminal"
forge script script/SendCrossChainMessage.s.sol:SendCrossChainMessage --broadcast
```

<Aside type="note">
  1. The `--broadcast` flag is used to broadcast transactions to an actual network. 2. You can get detailed runtime logs
  by using the `-vvvv` verbosity flag.
</Aside>

4. Create a new file named `VerifyCrossChainMessage.s.sol` in the `script` directory and paste the following code inside it:

```solidity filename="script/VerifyCrossChainMessage.s.sol"
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.24;

import {Script, console} from "forge-std/Script.sol";
import {Receiver} from "../src/Receiver.sol";

contract VerifyCrossChainMessage is Script {

    bytes32 constant ZERO_BYTES32 = bytes32(0);

    function run() public {

        address receiverAddress = PASTE_RECEIVER_ADDRESS_HERE;
        require(receiverAddress != address(0), "Set RECEIVER_ADDRESS (in .env or in script)");

        console.log("Connecting to Ethereum Sepolia...");
        uint256 sepoliaFork = vm.createFork(vm.rpcUrl("sepolia"));
        vm.selectFork(sepoliaFork);

        console.log("Checking for received message...\n");
        Receiver receiver = Receiver(receiverAddress);

        (bytes32 messageId, string memory text) = receiver
            .getLastReceivedMessageDetails();

        if (messageId == ZERO_BYTES32) {
            console.log("No message received yet.");
            console.log("Please wait a bit longer and try again.");
            revert("No message received yet");
        }

        console.log("Received Message ID:");
        console.logBytes32(messageId);
        console.log(string.concat('Received Text: "', text, '"'));
    }
}
```

5. Run the following command to verify the cross-chain message:

```bash filename="terminal"
forge script script/VerifyCrossChainMessage.s.sol:VerifyCrossChainMessage
```

</Accordion>
