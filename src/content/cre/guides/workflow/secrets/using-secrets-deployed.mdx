---
section: cre
title: "Using Secrets with Deployed Workflows"
date: Last Modified
metadata:
  description: "Secure your deployed workflows: learn to store and manage secrets in the Vault DON for deployed workflows running on DONs."
  datePublished: "2025-11-04"
  lastModified: "2025-11-04"
---

import { Aside, CodeHighlightBlockMulti } from "@components"

When your workflow is deployed, it cannot access your local `.env` file or environment variables. Instead, secrets must be stored in the **Vault DON**—a decentralized, secure secret storage system that your deployed workflows can access at runtime.

This guide explains how to manage secrets for deployed workflows using the `cre secrets` CLI commands.

{/* prettier-ignore */}
<Aside type="note" title="For local simulation">
  If you're developing and testing locally with `cre workflow simulate`, you don't need the Vault DON. See [Using Secrets in Simulation](/cre/guides/workflow/secrets/using-secrets-simulation) instead.
</Aside>

## Prerequisites

Before managing secrets for deployed workflows, ensure you have:

1. **CRE CLI installed**: See the [Installation Guide](/cre/getting-started/cli-installation/macos-linux)
1. **Authentication**: You must be logged in with `cre login`
1. **Owner address configured**: Your `workflow-owner-address` must be set in your project configuration

## How secrets work with deployed workflows

The workflow is similar to local development, but with a critical difference in where secrets are stored:

1. **Declare**: Define secret identifiers in a YAML file
1. **Store**: Push secrets to the Vault DON using `cre secrets create`
1. **Use**: Your deployed workflow accesses secrets from the Vault using `runtime.GetSecret()`

**Key difference from simulation:**

- **Local simulation**: Secrets read from your environment variables or `.env` file on your machine
- **Deployed workflows**: Secrets retrieved from Vault DON by the workflow

## Step-by-step guide

### Step 1: Create a secrets YAML file

Create a YAML file at the root of your project that declares the secrets you want to store.

**Example `production-secrets.yaml`:**

```yaml
secretsNames:
  API_KEY:
    - API_KEY_VALUE

  DATABASE_URL:
    - DATABASE_URL_VALUE
```

**Structure:**

- `secretsNames` — Top-level key containing all secrets
- Each secret has:
  - **Key** (e.g., `API_KEY`) — The identifier your workflow code will use
  - **Value** — An array containing the environment variable name that holds the actual value

{/* prettier-ignore */}
<Aside type="caution" title="Don't commit secrets files">
  Add your production secrets YAML files to `.gitignore`. Never commit them to version control.
</Aside>

### Step 2: Provide secret values as environment variables

Set the actual secret values as environment variables. These can be provided in two ways:

**Option A: Export in your shell**

```bash
export API_KEY_VALUE="your-actual-api-key"
export DATABASE_URL_VALUE="postgresql://user:pass@host:5432/db"
```

**Option B: Use a `.env` file**

Create a `.env` file (or add to your existing one):

```bash
# .env
API_KEY_VALUE=your-actual-api-key
DATABASE_URL_VALUE=postgresql://user:pass@host:5432/db
```

The `cre` CLI will automatically load variables from `.env` when you run the commands.

{/* prettier-ignore */}
<Aside type="tip" title="Use 1Password CLI">
  For enhanced security, use [1Password CLI](/cre/guides/workflow/secrets/managing-secrets-1password) to inject secrets without storing them in plaintext files.
</Aside>

### Step 3: Upload secrets to the Vault DON

Use the `cre secrets create` command to upload your secrets to the Vault:

```bash
cre secrets create production-secrets.yaml --target production-settings
```

**What happens:**

1. The CLI reads your YAML file and environment variables
1. It registers the request onchain (for authorization)
1. It submits the secrets to the Vault DON
1. The secrets are stored securely and associated with your owner address

**Example output:**

```bash
{"level":"info","owner":"<your-owner-address>","digest":"041eb7a8...","time":"2025-10-22T00:14:56+02:00","message":"IsRequestAllowlisted query succeeded"}
{"level":"info","digest":"041eb7a8...","deadline":"2025-10-23T22:14:56Z","time":"2025-10-22T00:14:59+02:00","message":"AllowlistRequest submitted"}
Digest allowlisted; proceeding to gateway POST
Secret created: secret_id=API_KEY, owner=<your-owner-address>, namespace=main
Secret created: secret_id=DATABASE_URL, owner=<your-owner-address>, namespace=main
```

{/* prettier-ignore */}
<Aside type="note" title="Default timeout">
  Secrets operations have a 48-hour timeout by default. You can customize this with the `--timeout` flag (e.g., `--timeout 1h` or `--timeout 7d`).
</Aside>

### Step 4: Use secrets in your workflow code

Your workflow code uses the same API to access secrets, whether running in local simulation or deployed to a workflow DON. The CRE runtime automatically retrieves secrets from the appropriate source.

{/* prettier-ignore */}
<Aside type="note" title="Namespace parameter">
  The `namespace` parameter is **optional** and only relevant for deployed workflows using the Vault DON. If omitted, it defaults to `"main"`. For local simulation, the namespace parameter is ignored—secrets are read from your `.env` file regardless.
</Aside>

<CodeHighlightBlockMulti
  languages={{
    ts: {
      code: `import { cre, type Runtime } from "@chainlink/cre-sdk"

const onCronTrigger = (runtime: Runtime<Config>): string => {
// Fetch the secret from the Vault DON (uses default "main" namespace)
const secret = runtime.getSecret({ id: "API_KEY" }).result()
const apiKey = secret.value

runtime.log(\`Using API key: \${apiKey.substring(0, 4)}...\`)

// Use the secret in your workflow logic
// ...

return "Success"
}`,
      title: "Fetching Secrets (TypeScript)",
    },
    go: {
      code: `import (
"github.com/smartcontractkit/cre-sdk-go/cre"
protos "github.com/smartcontractkit/chainlink-protos/cre/go/sdk"
)

func onCronTrigger(config *Config, runtime cre.Runtime, trigger *cron.Payload) (\*MyResult, error) {
logger := runtime.Logger()

    // Fetch the secret from the Vault DON (uses default "main" namespace)
    secretReq := &protos.SecretRequest{Id: "API_KEY"}
    secret, err := runtime.GetSecret(secretReq).Await()
    if err != nil {
    	return nil, err
    }

    apiKey := secret.Value
    logger.Info("Using API key", "prefix", apiKey[:4])

    // Use the secret in your workflow logic
    // ...

    return &MyResult{}, nil

}`,
title: "Fetching Secrets (Go)",
},
}}
/>

**Important:**

- The secret identifier (`"API_KEY"`) must match what you declared in your YAML file
- Secrets are fetched at runtime from the Vault DON
- The namespace parameter is optional—defaults to `"main"` if omitted
- The same code works for both simulation (reads from `.env`) and production (reads from Vault)

### Step 5: Verify secrets are stored

You can list all secrets stored in the Vault for your owner address:

```bash
cre secrets list --target production-settings
```

**Example output:**

```
{"level":"info","owner":"<your-owner-address>","digest":"225d8b6f...","time":"2025-10-22T19:10:12-05:00","message":"IsRequestAllowlisted query succeeded"}
{"level":"info","digest":"225d8b6f...","deadline":"2025-10-25T00:10:12Z","time":"2025-10-22T19:10:16-05:00","message":"AllowlistRequest submitted"}

Digest allowlisted; proceeding to gateway POST: owner=<your-owner-address>, requestID=f9148fcb-3e4e-45bf-bbde-2124ddd577e4, digest=0x225d8b6f...
Secret identifier: secret_id=API_KEY, owner=<your-owner-address>, namespace=main
Secret identifier: secret_id=DATABASE_URL, owner=<your-owner-address>, namespace=main
```

{/* prettier-ignore */}
<Aside type="note" title="Security: List only shows IDs">
  The `list` command only shows secret identifiers, never the actual secret values. Secret values are only accessible to your deployed workflows at runtime.
</Aside>

## Managing secrets lifecycle

### Updating secrets

To update existing secrets, use the `cre secrets update` command:

```bash
# Update your environment variable with the new value
export API_KEY_VALUE="new-api-key-value"

# Update the secret in the Vault
cre secrets update production-secrets.yaml --target production-settings
```

**Example output:**

```
{"level":"info","owner":"<your-owner-address>","digest":"10854ac2...","time":"2025-10-22T19:12:32-05:00","message":"IsRequestAllowlisted query succeeded"}
{"level":"info","digest":"10854ac2...","deadline":"2025-10-25T00:12:32Z","time":"2025-10-22T19:12:40-05:00","message":"AllowlistRequest submitted"}

Digest allowlisted; proceeding to gateway POST: owner=<your-owner-address>, requestID=7433514f-4008-46dd-822a-633732b64ec9, digest=0x10854ac2...
Secret updated: secret_id=API_KEY, owner=<your-owner-address>, namespace=main
Secret updated: secret_id=DATABASE_URL, owner=<your-owner-address>, namespace=main
```

{/* prettier-ignore */}
<Aside type="note" title="Update vs. Create">
  - `create` adds new secrets
  - `update` modifies existing secrets
  - You cannot update a secret that doesn't exist—use `create` first
</Aside>

### Deleting secrets

To remove secrets from the Vault:

**Step 1: Create a deletion YAML file** (`secrets-to-delete.yaml`):

```yaml
secretsNames:
  - API_KEY
  - DATABASE_URL
```

{/* prettier-ignore */}
<Aside type="note" title="Delete uses a simpler YAML format">
  Unlike `create` and `update` which map secret IDs to environment variables, the `delete` command uses a simple list of secret IDs under `secretsNames`.
</Aside>

**Step 2: Run the delete command:**

```bash
cre secrets delete secrets-to-delete.yaml --target production-settings
```

{/* prettier-ignore */}
<Aside type="caution" title="Permanent deletion">
  Deleting secrets is permanent and cannot be undone. Double-check your secret identifiers before running this command.
</Aside>

## About namespaces

When you look at CLI outputs, you'll notice secrets are organized by **namespaces**. A namespace is simply a way to group related secrets together.

{/* prettier-ignore */}
<Aside type="note" title="Default namespace">
  In the current CLI version, all secrets operations (`create`, `update`, `delete`) automatically use the default `"main"` namespace. This is why you see `namespace=main` in the output. Custom namespace support for these commands may be added in future CLI versions.
</Aside>

## Using with multi-sig wallets

All `cre secrets` commands support the `--unsigned` flag for multi-sig wallet operations. This generates raw transaction data instead of sending transactions directly.

For complete multi-sig setup and usage, see [Using Multi-sig Wallets](/cre/guides/operations/using-multisig-wallets).

## Troubleshooting

### "Secret not found" error in deployed workflow

**Problem:** Your workflow throws a "secret not found" error when calling `runtime.GetSecret()`.

**Solution:**

1. Verify the secret exists: `cre secrets list --target production-settings`
1. Check that the secret ID in your code matches exactly
1. Recreate the secret if necessary: `cre secrets create ...`

### "Timeout expired" error

**Problem:** The CLI returns a timeout error when creating/updating secrets.

**Solution:**
The onchain authorization has expired. Re-run the command to create a new authorization.

### Different secrets for simulation vs. production

**Problem:** You want different secret values when simulating vs. running in production.

**Solution:**

- For simulation: Store values in your local `.env` file
- For production: Use `cre secrets create` with different values
- The secret IDs stay the same—only the values differ

## Learn more

- **[Secrets CLI Reference](/cre/reference/cli/secrets)** — Complete CLI command documentation
- **[Using Secrets in Simulation](/cre/guides/workflow/secrets/using-secrets-simulation)** — For local development
- **[Managing Secrets with 1Password](/cre/guides/workflow/secrets/managing-secrets-1password)** — Best practice for secure secret management
- **[Using Multi-sig Wallets](/cre/guides/operations/using-multisig-wallets)** — For multi-sig secret operations
