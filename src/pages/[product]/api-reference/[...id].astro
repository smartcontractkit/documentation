---
// [product]/api-reference/[...id].astro

import { getCollection, render } from "astro:content"
import DocsLayout from "~/layouts/DocsLayout.astro"
import { VERSIONS, type Collection } from "@config/versions"
import type { BaseFrontmatter } from "~/content.config.ts"

interface MyEntry {
  id: string
  collection: Collection
  data: BaseFrontmatter
  body?: string
}

interface MyRoute {
  params: { product: Collection; id: string }
  props: { entry: MyEntry }
}

export async function getStaticPaths(): Promise<MyRoute[]> {
  console.log("=> getStaticPaths() for [product]/api-reference/[...id].astro called!")

  const versionToNoDots = (version: string) => version.replace(/\./g, "")

  const paths: MyRoute[] = []

  for (const [product, versions] of Object.entries(VERSIONS)) {
    const allEntries = await getCollection(product as Collection)

    // Filter only "api-reference/"
    const apiEntries = allEntries.filter((e: MyEntry) => e.id.startsWith("api-reference/"))

    for (const version of versions.ALL) {
      // 1) Convert "v1.5.1" => "v151" to match Astro's actual ID
      const folderVersion = versionToNoDots(version)

      // 2) Find "api-reference/v151/index" or "...index.mdx"
      const indexPath = `api-reference/${folderVersion}/index`
      const versionEntry = apiEntries.find(
        (ent: MyEntry) => ent.id === indexPath || ent.id === `${indexPath}.mdx`
      ) as MyEntry

      if (versionEntry) {
        // 3) Add a route for the version's "index" page at /ccip/api-reference/v1.5.1
        paths.push({
          params: { product: product as Collection, id: version }, // show the dotted version in the URL
          props: {
            entry: {
              id: versionEntry.id,
              collection: product as Collection,
              data: versionEntry.data,
            },
          },
        })

        // 4) Additional docs in "api-reference/v151/"
        const versionDocs = apiEntries.filter(
          (doc: MyEntry) =>
            doc.id.startsWith(`api-reference/${folderVersion}/`) &&
            doc.id !== `api-reference/${folderVersion}/index` &&
            doc.id !== `api-reference/${folderVersion}/index.mdx`
        )

        for (const docEntry of versionDocs as MyEntry[]) {
          // e.g. "api-reference/v151/burn-token-pool.mdx" => "v151/burn-token-pool"
          let docSlug = docEntry.id.replace("api-reference/", "").replace(/\.(md|mdx)$/, "")

          // 5) Replace the no-dot folder name => dotted version for the final route
          // e.g. "v151/burn-token-pool" => "v1.5.1/burn-token-pool"
          docSlug = docSlug.replace(folderVersion, version)

          paths.push({
            params: { product: product as Collection, id: docSlug },
            props: {
              entry: {
                id: docEntry.id,
                collection: product as Collection,
                data: docEntry.data,
              },
            },
          })

          console.log(`(PRODUCT=${product}) => /${product}/api-reference/${docSlug}`)
        }
      }
    }
  }

  return paths
}

// normal page code
interface Props {
  entry: MyEntry
}

const props = Astro.props as Props
const { entry } = props

const { Content, headings } = await render(entry)
---

<DocsLayout frontmatter={entry.data} {headings}>
  <Content />
</DocsLayout>
