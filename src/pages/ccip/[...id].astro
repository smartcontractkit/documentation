---
import DocsLayout from "~/layouts/DocsLayout.astro"
import TutorialLayout from "~/layouts/TutorialLayout.astro"
import { getCollection, render, type CollectionEntry } from "astro:content"

type ContentProps = {
  kind: "content"
  entry: CollectionEntry<"ccip">
}

type RedirectProps = {
  kind: "redirect"
  to: string
}

type Props = ContentProps | RedirectProps

export async function getStaticPaths() {
  const formatVersionSegment = (part: string): string => {
    const match = part.match(/^v(\d+)$/)
    if (!match) return part

    const digits = match[1]

    // v20  -> v2.0
    if (digits.length === 2) {
      return `v${digits[0]}.${digits[1]}`
    }

    // v161 -> v1.6.1
    // v150 -> v1.5.0
    if (digits.length === 3) {
      return `v${digits[0]}.${digits[1]}.${digits[2]}`
    }

    return part
  }

  const normalizeUrlPath = (entryId: string): string => {
    let urlPath = entryId.replace(/\.(md|mdx)$/, "")
    urlPath = urlPath.replace(/\/index$/, "")
    if (urlPath === "index") urlPath = ""

    // Astro content slugs collapse dots in version segments:
    // - v2.0   → v20
    // - v1.6   → v16
    // - v1.6.1 → v161
    // Restore the dotted form so URLs match our docs structure.
    urlPath = urlPath
      .split("/")
      .map((part) => formatVersionSegment(part))
      .join("/")

    return urlPath
  }

  const ccipEntries = await getCollection("ccip")
  const paths: { params: { id: string }; props: Props }[] = []
  const seen = new Set<string>()

  const addPath = (id: string, props: Props) => {
    if (!id) return
    if (seen.has(id)) return
    seen.add(id)
    paths.push({ params: { id }, props })
  }

  for (const entry of ccipEntries) {
    const urlPath = normalizeUrlPath(entry.id)

    // Only handle versioned CCIP docs here.
    if (!urlPath.startsWith("v1.6") && !urlPath.startsWith("v2.0")) {
      continue
    }

    // Versioned page (content)
    addPath(urlPath, { kind: "content", entry })

    // Legacy /ccip/* URLs → /ccip/v2.0/* (except /ccip itself, handled by /ccip/index.astro)
    if (urlPath === "v2.0") continue
    if (urlPath.startsWith("v2.0/")) {
      const legacyPath = urlPath.replace(/^v2\.0\//, "")
      addPath(legacyPath, { kind: "redirect", to: `/ccip/v2.0/${legacyPath}` })
    }
  }

  return paths
}

const props = Astro.props as Props

let Content: any
let headings: any
let frontmatter: any
let Layout: any
let redirectTo: string | undefined

if (props.kind === "redirect") {
  redirectTo = props.to
} else {
  const entry = props.entry
  const renderResult = await render(entry)
  Content = renderResult.Content
  headings = renderResult.headings
  frontmatter = entry.data

  // Only use TutorialLayout for the interactive Remix tutorial
  const isRemixTutorial =
    entry.id === "v1.6/tutorials/evm/cross-chain-tokens/register-from-eoa-remix" ||
    entry.id === "v2.0/tutorials/evm/cross-chain-tokens/register-from-eoa-remix" ||
    entry.id.endsWith("/tutorials/evm/cross-chain-tokens/register-from-eoa-remix")

  Layout = isRemixTutorial ? TutorialLayout : DocsLayout
}
---

{
  redirectTo ? (
    <>
      <meta name="robots" content="noindex, follow" />
      <meta http-equiv="refresh" content={`0; url=${redirectTo}`} />
    </>
  ) : (
    <Layout frontmatter={frontmatter} headings={headings}>
      <Content />
    </Layout>
  )
}
