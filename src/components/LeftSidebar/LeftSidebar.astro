---
import type { Sections } from "~/content.config.ts"
import { SIDEBAR } from "../../config/index.ts"
import type { SectionEntry, SectionContent } from "../../config/index.ts"
import RecursiveSidebar from "./RecursiveSidebar.astro"
import { LanguageSwitcherDropdown } from "~/components/LanguageSwitcherDropdown.js"
import { ChainTypeSelector } from "~/components/ChainSelector/index.js"
import { isChainAwareSection } from "~/config/chainTypes.js"
import styles from "./leftSidebar.module.css"

type SectionEntryWithParent = SectionEntry & { parentSection?: string }

export type Props = {
  currentPage: string
  section?: Sections
}

const { currentPage, section } = Astro.props

// Check if this section supports chain type filtering
const showChainSelector = isChainAwareSection(section)

type CcipDocVersion = "v1.6" | "v2.0"

function getCcipDocVersionFromPath(pathname: string): CcipDocVersion | null {
  const match = pathname.match(/^\/ccip\/(v1\.6|v2\.0)(\/|$)/)
  return (match?.[1] as CcipDocVersion | undefined) ?? null
}

function isExternalUrl(url: string): boolean {
  return url.startsWith("http://") || url.startsWith("https://")
}

function rewriteCcipUrl(url: string, version: CcipDocVersion): string {
  if (!url || isExternalUrl(url)) return url

  const [rawPath, rawQuery] = url.split("?", 2)
  const query = rawQuery ? `?${rawQuery}` : ""

  // Only rewrite CCIP links that come from the sidebar config
  if (!rawPath.startsWith("ccip")) return url

  // Keep CCIP Directory unversioned (the directory is a separate app/page route)
  if (rawPath.startsWith("ccip/directory")) return url

  // Remove the "ccip/" prefix (or "ccip" itself) so we can insert the version.
  let remainder = rawPath === "ccip" ? "" : rawPath.replace(/^ccip\//, "")

  // If the sidebar already has a version (future-proof), normalize it to the requested one.
  remainder = remainder.replace(/^(v1\.6|v2\.0)(\/|$)/, "")

  const rewritten = remainder ? `ccip/${version}/${remainder}` : `ccip/${version}`
  return `${rewritten}${query}`
}

function rewriteCcipSidebarItems(items: SectionContent[], version: CcipDocVersion): SectionContent[] {
  return items.map((item) => ({
    ...item,
    url: item.url ? rewriteCcipUrl(item.url, version) : item.url,
    highlightAsCurrent: item.highlightAsCurrent?.map((url) => rewriteCcipUrl(url, version)),
    children: item.children ? rewriteCcipSidebarItems(item.children, version) : item.children,
  }))
}

function rewriteCcipSidebarSections(
  sections: SectionEntryWithParent[],
  version: CcipDocVersion
): SectionEntryWithParent[] {
  return sections.map((group) => ({
    ...group,
    contents: rewriteCcipSidebarItems(group.contents, version),
  }))
}

// Return whichever sections we need
function getSidebarSections(section?: Sections): SectionEntryWithParent[] {
  if (!section) {
    return []
  } else if (section === "global") {
    // Flatten all sidebar entries into one array
    return Object.entries(SIDEBAR).flatMap(([parentSection, entries]) => {
      return entries?.map((entry) => ({ ...entry, parentSection })) ?? []
    })
  }
  return SIDEBAR[section] ?? []
}

/**
 * Determines if a section should be expanded based on its contents
 */
function shouldExpandTopSection(contents: SectionEntry["contents"], currentPage: string): boolean {
  const normalizedCurrentPage = removeSlashes(currentPage.slice(1))

  // Helper function to check if an item or its children match the current page exactly
  function checkItem(item: SectionContent): boolean {
    // Check if current page matches this item exactly
    if (item.url) {
      const normalizedItemUrl = removeSlashes(item.url)

      // Direct match
      if (normalizedCurrentPage === normalizedItemUrl) {
        return true
      }

      // Check highlightAsCurrent array
      if (item.highlightAsCurrent?.some((url) => normalizedCurrentPage === removeSlashes(url))) {
        return true
      }
    }

    // Check children recursively for exact matches
    if (item.children) {
      return item.children.some(checkItem)
    }

    return false
  }

  // Check all items in the section for exact matches
  return contents.some(checkItem)
}

function removeSlashes(url: string): string {
  let sanitizedUrl = url
  sanitizedUrl = sanitizedUrl.split("?parent")[0]
  if (sanitizedUrl.charAt(0) == "/") sanitizedUrl = sanitizedUrl.substr(1)
  if (sanitizedUrl.charAt(sanitizedUrl.length - 1) == "/")
    sanitizedUrl = sanitizedUrl.substr(0, sanitizedUrl.length - 1)
  return sanitizedUrl
}

const sidebarSections = (() => {
  const base = getSidebarSections(section)

  if (section !== "ccip") return base

  const version = getCcipDocVersionFromPath(currentPage) ?? "v2.0"
  return rewriteCcipSidebarSections(base, version)
})()
---

<nav aria-labelledby="grid-left" class={styles.nav}>
  <div class={styles.sidebarDropdowns}>
    {section === "cre" && <LanguageSwitcherDropdown client:only="react" />}
    {showChainSelector && <ChainTypeSelector client:only="react" />}
  </div>
  <ul class={styles.navGroups} data-sticky>
    {
      sidebarSections.map((group) => (
        <li
          style={section === "global" ? { display: "none" } : {}}
          class={group.parentSection ? `parent-${group.parentSection}` : ""}
        >
          <details open={shouldExpandTopSection(group.contents, currentPage)}>
            <summary class={styles.navGroupTitle}>{group.section}</summary>
            <ul class={styles.navGroupEntries}>
              <RecursiveSidebar items={group.contents} currentPage={currentPage} />
            </ul>
          </details>
        </li>
      ))
    }
  </ul>
</nav>

<style is:global>
  .nav-link svg {
    min-height: 12px;
    min-width: 12px;
    opacity: 0;
    display: none;
  }

  .nav-link[aria-current="page"] svg {
    opacity: 0;
  }
</style>

<script>
  import { initializeChainType } from "~/stores/chainType.js"

  /**
   * Initialize chain type selection from URL on page load
   * This detects the chain from the URL path (e.g., /ccip/tutorials/svm/... â†’ solana)
   */
  initializeChainType()

  /**
   * Re-initialize on client-side navigation (Astro view transitions)
   */
  document.addEventListener("astro:after-swap", () => {
    initializeChainType()
  })

  /**
   * Handles section visibility based on URL parameters
   * - Shows/hides sections based on the 'parent' query parameter
   * - Runs on initial load and after navigation
   */
  const attachContentScripts = () => {
    const parentSection = new URLSearchParams(window.location.search).get("parent") || "global"
    if (parentSection) {
      for (let elem of document.querySelectorAll(`.parent-${parentSection}`)) {
        ;(elem as HTMLElement).style.display = "block"
      }
    }
  }

  // Runs on initial navigation
  attachContentScripts()
  // Runs on view transitions navigation
  document.addEventListener("astro:after-swap", attachContentScripts)
</script>

<script>
  import { selectedChainType } from "~/stores/chainType.js"

  /**
   * Filters sidebar items based on selected chain type
   * Triggers the unified filter in RecursiveSidebar that respects BOTH chain type AND language
   */
  function filterSidebarByChainType() {
    // trigger a languageChanged event to run the unified filter
    window.dispatchEvent(new CustomEvent("languageChanged"))
  }

  // Run on initial load
  filterSidebarByChainType()

  // Run after view transitions
  document.addEventListener("astro:after-swap", filterSidebarByChainType)

  // Subscribe to chain type changes
  selectedChainType.subscribe(() => {
    filterSidebarByChainType()
  })
</script>
