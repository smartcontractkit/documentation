---
import type { Collection } from "~/content.config.ts"
import { buildVersionUrl, getVersionReleaseDate } from "../utils/versions.ts"
import { extractVersionInfo } from "../utils/extractVersionInfo.ts"
import { PAGE_AVAILABILITY } from "@config/versions/page-availability"

interface Props {
  product: Collection
  currentPath: string
}

const { product, currentPath } = Astro.props

// Extract version information using shared utility
const extractedVersionInfo = extractVersionInfo(product, currentPath)
if (!extractedVersionInfo) {
  throw new Error(`No version configuration found for product: ${product}`)
}

const {
  validatedVersion,
  isNotLatest,
  isDeprecated,
  releaseDate,
  vmType,
  versionConfig,
  sortedVersions,
  basePath,
  productConfig,
  canonicalUrl,
} = extractedVersionInfo

// Extract page path to check availability
// Support both path patterns
const standardPageMatch = currentPath.match(new RegExp(`/${product}/api-reference/v[^/]+/(.+?)/?$`))
const extendedPageMatch = currentPath.match(new RegExp(`/${product}/api-reference/(?:evm|svm)/v[^/]+/(.+?)/?$`))
const pagePath = extendedPageMatch?.[1] || standardPageMatch?.[1] || null
const productAvailability = PAGE_AVAILABILITY[product]

// Function to check if a version is available for this page
const isVersionAvailable = (version: string): boolean => {
  let isAvailable = true

  if (pagePath && productAvailability) {
    const pageConfig = productAvailability[pagePath]

    if (pageConfig) {
      if (pageConfig.onlyAvailableIn) {
        isAvailable = pageConfig.onlyAvailableIn.includes(version)
      } else if (pageConfig.notAvailableIn) {
        isAvailable = !pageConfig.notAvailableIn.includes(version)
      }
    }
  }

  return isAvailable
}

// Generate changelog URL (points to API reference index)
const changelogUrl = basePath

// Filter versions based on availability
const availableVersions = sortedVersions.filter((version) => isVersionAvailable(version))

// SEO: Structured data generation REMOVED - now handled by unified structuredData.ts

// SEO: Version alternates with metadata (only for available versions)
const versions = availableVersions.map((version) => ({
  url: buildVersionUrl(productConfig, currentPath, validatedVersion, version).replace(/\/+$/, ""),
  version,
  isLatest: version === versionConfig.LATEST,
  isDeprecated: versionConfig.DEPRECATED?.includes(version) ?? false,
}))
---

{/* SEO: Structured data - REMOVED: Now handled by unified structuredData.ts */}

{/* SEO: Version metadata */}
<meta name="version" content={validatedVersion} />
<meta name="version-status" content={isNotLatest ? "outdated" : "latest"} />
{isDeprecated && <meta name="robots" content="noindex,follow" />}

{/* SEO: Version alternates - only for available versions */}
{
  versions.map(({ url, version, isLatest, isDeprecated }) => (
    <link
      rel={isLatest ? "canonical" : "alternate"}
      href={url}
      hreflang="x-default"
      title={`Version ${version}${isLatest ? " (Latest)" : ""}${isDeprecated ? " (Deprecated)" : ""}`}
      data-version={version}
    />
  ))
}

{/* SEO: Version changelog metadata */}
{
  releaseDate && (
    <>
      <meta name="version-changelog" content={changelogUrl} />
      <meta name="version-release-date" content={releaseDate} />
      <link
        rel="alternate"
        type="text/html"
        href={changelogUrl}
        title={`API Reference for ${product} ${validatedVersion}`}
      />
    </>
  )
}
